{"version":3,"file":"SparqlEndpointFetcher.js","sourceRoot":"","sources":["SparqlEndpointFetcher.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport * as isStream from 'is-stream';\nimport { StreamParser } from 'n3';\nimport { readableFromWeb } from 'readable-from-web';\nimport type { Readable } from 'readable-stream';\nimport { type InsertDeleteOperation, type ManagementOperation, Parser as SparqlParser } from 'sparqljs';\nimport { type ISettings as ISparqlJsonParserArgs, SparqlJsonParser } from 'sparqljson-parse';\nimport { type ISettings as ISparqlXmlParserArgs, SparqlXmlParser } from 'sparqlxml-parse';\nimport * as stringifyStream from 'stream-to-string';\n\n/**\n * A SparqlEndpointFetcher can send queries to SPARQL endpoints,\n * and retrieve and parse the results.\n */\nexport class SparqlEndpointFetcher {\n  public static readonly CONTENTTYPE_SPARQL_JSON = 'application/sparql-results+json';\n  public static readonly CONTENTTYPE_SPARQL_XML = 'application/sparql-results+xml';\n  public static readonly CONTENTTYPE_TURTLE = 'text/turtle';\n  public static readonly CONTENTTYPE_SPARQL = `${SparqlEndpointFetcher.CONTENTTYPE_SPARQL_JSON};q=1.0,${SparqlEndpointFetcher.CONTENTTYPE_SPARQL_XML};q=0.7`;\n\n  protected readonly method: 'GET' | 'POST';\n  protected readonly timeout?: number;\n  public additionalUrlParams: URLSearchParams;\n  protected readonly defaultHeaders: Headers;\n  public readonly fetchCb?: (input: Request | string, init?: RequestInit) => Promise<Response>;\n\n  protected readonly sparqlParsers: Record<string, ISparqlResultsParser>;\n  protected readonly sparqlJsonParser: SparqlJsonParser;\n  protected readonly sparqlXmlParser: SparqlXmlParser;\n\n  public constructor(args?: ISparqlEndpointFetcherArgs) {\n    this.method = args?.method ?? 'POST';\n    this.timeout = args?.timeout;\n    this.additionalUrlParams = args?.additionalUrlParams ?? new URLSearchParams();\n    this.defaultHeaders = args?.defaultHeaders ?? new Headers();\n    this.fetchCb = args?.fetch;\n    this.sparqlJsonParser = new SparqlJsonParser(args);\n    this.sparqlXmlParser = new SparqlXmlParser(args);\n    this.sparqlParsers = {\n      [SparqlEndpointFetcher.CONTENTTYPE_SPARQL_JSON]: {\n        parseBooleanStream: sparqlResponseStream =>\n          this.sparqlJsonParser.parseJsonBooleanStream(sparqlResponseStream),\n        parseResultsStream: sparqlResponseStream =>\n          this.sparqlJsonParser.parseJsonResultsStream(sparqlResponseStream),\n      },\n      [SparqlEndpointFetcher.CONTENTTYPE_SPARQL_XML]: {\n        parseBooleanStream: sparqlResponseStream =>\n          this.sparqlXmlParser.parseXmlBooleanStream(sparqlResponseStream),\n        parseResultsStream: sparqlResponseStream =>\n          this.sparqlXmlParser.parseXmlResultsStream(sparqlResponseStream),\n      },\n    };\n  }\n\n  /**\n   * Get the query type of the given query.\n   *\n   * This will parse the query and thrown an exception on syntax errors.\n   *\n   * @param {string} query A query.\n   * @return {'SELECT' | 'ASK' | 'CONSTRUCT' | 'UNKNOWN'} The query type.\n   */\n  public getQueryType(query: string): 'SELECT' | 'ASK' | 'CONSTRUCT' | 'UNKNOWN' {\n    const parsedQuery = new SparqlParser({ sparqlStar: true }).parse(query);\n    if (parsedQuery.type === 'query') {\n      return parsedQuery.queryType === 'DESCRIBE' ? 'CONSTRUCT' : parsedQuery.queryType;\n    }\n    return 'UNKNOWN';\n  }\n\n  /**\n   * Get the query type of the given update query.\n   *\n   * This will parse the update query and thrown an exception on syntax errors.\n   *\n   * @param {string} query An update query.\n   * @return {'UNKNOWN' | UpdateTypes} The included update operations.\n   */\n  public getUpdateTypes(query: string): 'UNKNOWN' | IUpdateTypes {\n    const parsedQuery = new SparqlParser({ sparqlStar: true }).parse(query);\n    if (parsedQuery.type === 'update') {\n      const operations: IUpdateTypes = {};\n      for (const update of parsedQuery.updates) {\n        if ('type' in update) {\n          operations[update.type] = true;\n        } else {\n          operations[update.updateType] = true;\n        }\n      }\n      return operations;\n    }\n    return 'UNKNOWN';\n  }\n\n  /**\n   * Send a SELECT query to the given endpoint URL and return the resulting bindings stream.\n   * @see IBindings\n   * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).\n   * @param {string} query    A SPARQL query string.\n   * @return {Promise<NodeJS.ReadableStream>} A stream of {@link IBindings}.\n   */\n  public async fetchBindings(endpoint: string, query: string): Promise<NodeJS.ReadableStream> {\n    const [ contentType, responseStream ] = await this.fetchRawStream(\n      endpoint,\n      query,\n      SparqlEndpointFetcher.CONTENTTYPE_SPARQL,\n    );\n    const parser: ISparqlResultsParser | undefined = this.sparqlParsers[contentType];\n    if (!parser) {\n      throw new Error(`Unknown SPARQL results content type: ${contentType}`);\n    }\n    return parser.parseResultsStream(responseStream);\n  }\n\n  /**\n   * Send an ASK query to the given endpoint URL and return a promise resolving to the boolean answer.\n   * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).\n   * @param {string} query    A SPARQL query string.\n   * @return {Promise<boolean>} A boolean resolving to the answer.\n   */\n  public async fetchAsk(endpoint: string, query: string): Promise<boolean> {\n    const [ contentType, responseStream ] = await this.fetchRawStream(\n      endpoint,\n      query,\n      SparqlEndpointFetcher.CONTENTTYPE_SPARQL,\n    );\n    const parser: ISparqlResultsParser | undefined = this.sparqlParsers[contentType];\n    if (!parser) {\n      throw new Error(`Unknown SPARQL results content type: ${contentType}`);\n    }\n    return parser.parseBooleanStream(responseStream);\n  }\n\n  /**\n   * Send a CONSTRUCT/DESCRIBE query to the given endpoint URL and return the resulting triple stream.\n   * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).\n   * @param {string} query    A SPARQL query string.\n   * @return {Promise<Stream>} A stream of triples.\n   */\n  public async fetchTriples(endpoint: string, query: string): Promise<Readable & RDF.Stream> {\n    const [ contentType, responseStream ] = await this.fetchRawStream(\n      endpoint,\n      query,\n      SparqlEndpointFetcher.CONTENTTYPE_TURTLE,\n    );\n    return <Readable> <unknown> responseStream.pipe(new StreamParser({ format: contentType }));\n  }\n\n  /**\n   * Send an update query to the given endpoint URL using POST.\n   *\n   * @param {string} endpoint     A SPARQL endpoint URL. (without the `?query=` suffix).\n   * @param {string} query        A SPARQL query string.\n   */\n  public async fetchUpdate(endpoint: string, query: string): Promise<void> {\n    const abortController = new AbortController();\n    const defaultHeadersRaw: Record<string, string> = {};\n\n    // Headers object does not have other means to iterate it according to the typings\n    // eslint-disable-next-line unicorn/no-array-for-each\n    this.defaultHeaders.forEach((value, key) => {\n      defaultHeadersRaw[key] = value;\n    });\n\n    const init: RequestInit = {\n      method: 'POST',\n      headers: {\n        ...defaultHeadersRaw,\n        'content-type': 'application/sparql-update',\n      },\n      body: query,\n      signal: abortController.signal,\n    };\n\n    await this.handleFetchCall(endpoint, init, { ignoreBody: true });\n    abortController.abort();\n  }\n\n  /**\n   * Send a query to the given endpoint URL and return the resulting stream.\n   *\n   * This will only accept responses with the application/sparql-results+json content type.\n   *\n   * @param {string} endpoint     A SPARQL endpoint URL. (without the `?query=` suffix).\n   * @param {string} query        A SPARQL query string.\n   * @param {string} acceptHeader The HTTP accept to use.\n   * @return {Promise<[string, NodeJS.ReadableStream]>} The content type and SPARQL endpoint response stream.\n   */\n  public async fetchRawStream(\n    endpoint: string,\n    query: string,\n    acceptHeader: string,\n  ): Promise<[ string, NodeJS.ReadableStream ]> {\n    let url: string = this.method === 'POST' ? endpoint : `${endpoint}?query=${encodeURIComponent(query)}`;\n\n    // Initiate request\n    let body: URLSearchParams | undefined;\n    const headers: Headers = new Headers(this.defaultHeaders);\n    headers.append('Accept', acceptHeader);\n\n    if (this.method === 'POST') {\n      headers.append('Content-Type', 'application/x-www-form-urlencoded');\n      body = new URLSearchParams();\n      body.set('query', query);\n      for (const [ key, value ] of this.additionalUrlParams.entries()) {\n        body.set(key, value);\n      }\n      headers.append('Content-Length', body.toString().length.toString());\n    } else if (this.additionalUrlParams.toString().length > 0) {\n      url += `&${this.additionalUrlParams.toString()}`;\n    }\n\n    return this.handleFetchCall(url, { headers, method: this.method, body });\n  }\n\n  /**\n   * Helper function to generalize internal fetch calls.\n   *\n   * @param {string}      url     The URL to call.\n   * @param {RequestInit} init    Options to pass along to the fetch call.\n   * @param {any}         options Other specific fetch options.\n   * @return {Promise<[string, NodeJS.ReadableStream]>} The content type and SPARQL endpoint response stream.\n   */\n  private async handleFetchCall(\n    url: string,\n    init: RequestInit,\n    options?: { ignoreBody: boolean },\n  ): Promise<[ string, NodeJS.ReadableStream ]> {\n    let timeout;\n    let responseStream: NodeJS.ReadableStream | undefined;\n\n    if (this.timeout) {\n      const controller = new AbortController();\n      init.signal = controller.signal;\n      timeout = setTimeout(() => controller.abort(), this.timeout);\n    }\n\n    const httpResponse: Response = await (this.fetchCb ?? fetch)(url, init);\n\n    clearTimeout(timeout);\n\n    // Handle response body\n    if (!options?.ignoreBody && httpResponse.body) {\n      // Wrap WhatWG readable stream into a Node.js readable stream\n      // If the body already is a Node.js stream (in the case of node-fetch), don't do explicit conversion.\n      responseStream = <NodeJS.ReadableStream> (\n        isStream(httpResponse.body) ? httpResponse.body : readableFromWeb(httpResponse.body)\n      );\n    }\n\n    // Emit an error if the server returned an invalid response\n    if (!httpResponse.ok || (!responseStream && !options?.ignoreBody)) {\n      const simpleUrl = url.split('?').at(0);\n      const bodyString = responseStream ? await stringifyStream(responseStream) : 'empty response';\n      throw new Error(`Invalid SPARQL endpoint response from ${simpleUrl} (HTTP status ${httpResponse.status}):\\n${bodyString}`);\n    }\n\n    // Determine the content type\n    const contentType = httpResponse.headers.get('Content-Type')?.split(';').at(0) ?? '';\n\n    return [ contentType, responseStream! ];\n  }\n}\n\nexport interface ISparqlEndpointFetcherArgs extends ISparqlJsonParserArgs, ISparqlXmlParserArgs {\n  /**\n   * A custom HTTP method for issuing (non-update) queries, defaults to POST.\n   * Update queries are always issued via POST.\n   */\n  method?: 'POST' | 'GET';\n  additionalUrlParams?: URLSearchParams;\n  timeout?: number;\n  defaultHeaders?: Headers;\n  /**\n   * A custom fetch function.\n   */\n  fetch?: (input: Request | string, init?: RequestInit) => Promise<Response>;\n}\n\nexport interface ISparqlResultsParser {\n  parseResultsStream: (sparqlResponseStream: NodeJS.ReadableStream) => NodeJS.ReadableStream;\n  parseBooleanStream: (sparqlResponseStream: NodeJS.ReadableStream) => Promise<boolean>;\n}\n\nexport type IBindings = Record<string, RDF.Term>;\n\nexport type IUpdateTypes = {\n  [K in ManagementOperation['type'] | InsertDeleteOperation['updateType']]?: boolean;\n};\n"]}
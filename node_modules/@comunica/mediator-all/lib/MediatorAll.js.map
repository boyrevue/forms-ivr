{"version":3,"file":"MediatorAll.js","sourceRoot":"","sources":["MediatorAll.ts"],"names":[],"mappings":";;;AACA,yCAA0C;AAE1C;;;GAGG;AACH,MAAa,WAOX,SAAQ,eAAwB;IAChC,YAAmB,IAAmC;QACpD,KAAK,CAAC,IAAI,CAAC,CAAC;IACd,CAAC;IAEe,KAAK,CAAC,OAAO,CAAC,MAAS;QACrC,6CAA6C;QAC7C,MAAM,aAAa,GAAiC,EAAE,CAAC;QACvD,IAAI,WAA0C,CAAC;QAC/C,IAAI,CAAC;YACH,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QACrC,CAAC;QAAC,MAAM,CAAC;YACP,WAAW,GAAG,EAAE,CAAC;QACnB,CAAC;QACD,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE,CAAC;YACrC,MAAM,KAAK,GAAG,MAAM,UAAU,CAAC,KAAK,CAAC;YACrC,IAAI,KAAK,CAAC,QAAQ,EAAE,EAAE,CAAC;gBACrB,aAAa,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,UAAU,CAAC,KAAK,EAAE,QAAQ,EAAE,KAAK,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;YACjF,CAAC;QACH,CAAC;QAED,kCAAkC;QAClC,MAAM,OAAO,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC,MAAM,EAAE,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;QAEpH,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC;IACpB,CAAC;IAES,KAAK,CAAC,WAAW;QACzB,MAAM,IAAI,KAAK,CAAC,gDAAgD,CAAC,CAAC;IACpE,CAAC;CACF;AArCD,kCAqCC","sourcesContent":["import type { Actor, IAction, IActorOutput, IActorReply, IActorTest, IMediatorArgs, TestResult } from '@comunica/core';\nimport { Mediator } from '@comunica/core';\n\n/**\n * A comunica mediator that runs all actors that resolve their test.\n * This mediator will always resolve to the first actor's output.\n */\nexport class MediatorAll<\n  A extends Actor<I, T, O, TS>,\nI extends IAction,\nT extends IActorTest,\nO extends IActorOutput,\nTS = undefined,\n>\n  extends Mediator<A, I, T, O, TS> {\n  public constructor(args: IMediatorArgs<A, I, T, O, TS>) {\n    super(args);\n  }\n\n  public override async mediate(action: I): Promise<O> {\n    // Collect all actors that resolve their test\n    const passedResults: { actor: A; sideData: TS }[] = [];\n    let testResults: IActorReply<A, I, T, O, TS>[];\n    try {\n      testResults = this.publish(action);\n    } catch {\n      testResults = [];\n    }\n    for (const testResult of testResults) {\n      const reply = await testResult.reply;\n      if (reply.isPassed()) {\n        passedResults.push({ actor: testResult.actor, sideData: reply.getSideData() });\n      }\n    }\n\n    // Send action to all valid actors\n    const outputs = await Promise.all(passedResults.map(result => result.actor.runObservable(action, result.sideData)));\n\n    return outputs[0];\n  }\n\n  protected async mediateWith(): Promise<TestResult<A, TS>> {\n    throw new Error('Unsupported operation: MediatorAll#mediateWith');\n  }\n}\n"]}
{"version":3,"file":"ActorRdfJoinMultiBind.js","sourceRoot":"","sources":["ActorRdfJoinMultiBind.ts"],"names":[],"mappings":"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","sourcesContent":["import type { MediatorMergeBindingsContext } from '@comunica/bus-merge-bindings-context';\nimport type { MediatorQueryOperation } from '@comunica/bus-query-operation';\nimport type {\n  IActionRdfJoin,\n  IActorRdfJoinOutputInner,\n  IActorRdfJoinArgs,\n  IActorRdfJoinTestSideData,\n} from '@comunica/bus-rdf-join';\nimport { ActorRdfJoin } from '@comunica/bus-rdf-join';\nimport type { MediatorRdfJoinEntriesSort } from '@comunica/bus-rdf-join-entries-sort';\nimport { KeysInitQuery, KeysQueryOperation } from '@comunica/context-entries';\nimport type { TestResult } from '@comunica/core';\nimport { passTestWithSideData, failTest } from '@comunica/core';\nimport type { IMediatorTypeJoinCoefficients } from '@comunica/mediatortype-join-coefficients';\nimport type {\n  Bindings,\n  BindingsStream,\n  ComunicaDataFactory,\n  IJoinEntryWithMetadata,\n  IQueryOperationResultBindings,\n} from '@comunica/types';\nimport { BindingsFactory } from '@comunica/utils-bindings-factory';\nimport { getSafeBindings, materializeOperation } from '@comunica/utils-query-operation';\nimport { MultiTransformIterator, TransformIterator, UnionIterator } from 'asynciterator';\nimport { Factory, Algebra, Util } from 'sparqlalgebrajs';\n\n/**\n * A comunica Multi-way Bind RDF Join Actor.\n */\nexport class ActorRdfJoinMultiBind extends ActorRdfJoin<IActorRdfJoinMultiBindTestSideData> {\n  public readonly bindOrder: BindOrder;\n  public readonly selectivityModifier: number;\n  public readonly minMaxCardinalityRatio: number;\n  public readonly mediatorJoinEntriesSort: MediatorRdfJoinEntriesSort;\n  public readonly mediatorQueryOperation: MediatorQueryOperation;\n  public readonly mediatorMergeBindingsContext: MediatorMergeBindingsContext;\n\n  public constructor(args: IActorRdfJoinMultiBindArgs) {\n    super(args, {\n      logicalType: 'inner',\n      physicalName: 'bind',\n      canHandleUndefs: true,\n      isLeaf: false,\n    });\n  }\n\n  /**\n   * Create a new bindings stream that takes every binding of the base stream\n   * and binds it to the remaining patterns, evaluates those patterns, and emits all their bindings.\n   *\n   * @param bindOrder The order in which elements should be bound.\n   * @param baseStream The base stream.\n   * @param operations The operations to bind with each binding of the base stream.\n   * @param operationBinder A callback to retrieve the bindings stream of bound operations.\n   * @param optional If the original bindings should be emitted when the resulting bindings stream is empty.\n   * @return {BindingsStream}\n   */\n  public static createBindStream(\n    bindOrder: BindOrder,\n    baseStream: BindingsStream,\n    operations: Algebra.Operation[],\n    operationBinder: (boundOperations: Algebra.Operation[], operationBindings: Bindings)\n    => Promise<BindingsStream>,\n    optional: boolean,\n    algebraFactory: Factory,\n    bindingsFactory: BindingsFactory,\n  ): BindingsStream {\n    // Enable auto-start on sub-bindings during depth-first binding for best performance.\n    const autoStartSubBindings = bindOrder === 'depth-first';\n\n    // Create bindings function\n    const binder = (bindings: Bindings): BindingsStream => {\n      // We don't bind the filter because filters are always handled last,\n      // and we need to avoid binding filters of sub-queries, which are to be handled first. (see spec test bind10)\n      const subOperations = operations.map(operation => materializeOperation(\n        operation,\n        bindings,\n        algebraFactory,\n        bindingsFactory,\n        { bindFilter: true },\n      ));\n      const bindingsMerger = (subBindings: Bindings): Bindings | undefined => subBindings.merge(bindings);\n      return new TransformIterator(async() => (await operationBinder(subOperations, bindings))\n        .transform({ map: bindingsMerger }), { maxBufferSize: 128, autoStart: autoStartSubBindings });\n    };\n\n    // Create an iterator that binds elements from the base stream in different orders\n    switch (bindOrder) {\n      case 'depth-first':\n        return new MultiTransformIterator(baseStream, { autoStart: false, multiTransform: binder, optional });\n      case 'breadth-first':\n        return new UnionIterator(baseStream.transform({\n          map: binder,\n          optional,\n        }), { autoStart: false });\n      default:\n        // eslint-disable-next-line ts/restrict-template-expressions\n        throw new Error(`Received request for unknown bind order: ${bindOrder}`);\n    }\n  }\n\n  public async getOutput(\n    action: IActionRdfJoin,\n    sideData: IActorRdfJoinMultiBindTestSideData,\n  ): Promise<IActorRdfJoinOutputInner> {\n    const dataFactory: ComunicaDataFactory = action.context.getSafe(KeysInitQuery.dataFactory);\n    const algebraFactory = new Factory(dataFactory);\n    const bindingsFactory = await BindingsFactory.create(\n      this.mediatorMergeBindingsContext,\n      action.context,\n      dataFactory,\n    );\n\n    const entries = sideData.entriesSorted;\n    this.logDebug(\n      action.context,\n      'First entry for Bind Join: ',\n      () => ({\n        entry: entries[0].operation,\n        cardinality: entries[0].metadata.cardinality,\n        order: entries[0].metadata.order,\n        availableOrders: entries[0].metadata.availableOrders,\n      }),\n    );\n\n    // Close the non-smallest streams\n    for (const [ i, element ] of entries.entries()) {\n      if (i !== 0) {\n        element.output.bindingsStream.close();\n      }\n    }\n\n    // Take the stream with the lowest cardinality\n    const smallestStream: IQueryOperationResultBindings = entries[0].output;\n    const remainingEntries = [ ...entries ];\n    remainingEntries.splice(0, 1);\n\n    // Bind the remaining patterns for each binding in the stream\n    const subContext = action.context\n      .set(KeysQueryOperation.joinLeftMetadata, entries[0].metadata)\n      .set(KeysQueryOperation.joinRightMetadatas, remainingEntries.map(entry => entry.metadata));\n    const bindingsStream: BindingsStream = ActorRdfJoinMultiBind.createBindStream(\n      this.bindOrder,\n      smallestStream.bindingsStream,\n      remainingEntries.map(entry => entry.operation),\n      async(operations: Algebra.Operation[], operationBindings: Bindings) => {\n        // Send the materialized patterns to the mediator for recursive join evaluation.\n        const operation = operations.length === 1 ?\n          operations[0] :\n          // Flattening should only take place if none of the input operations have associated metadata\n          algebraFactory.createJoin(operations, operations.every(op => !op.metadata));\n        const output = getSafeBindings(await this.mediatorQueryOperation.mediate(\n          { operation, context: subContext?.set(KeysQueryOperation.joinBindings, operationBindings) },\n        ));\n        return output.bindingsStream;\n      },\n      false,\n      algebraFactory,\n      bindingsFactory,\n    );\n\n    return {\n      result: {\n        type: 'bindings',\n        bindingsStream,\n        metadata: () => this.constructResultMetadata(entries, entries.map(entry => entry.metadata), action.context),\n      },\n      physicalPlanMetadata: {\n        bindIndex: sideData.entriesUnsorted.indexOf(entries[0]),\n        bindOperation: entries[0].operation,\n        bindOperationCardinality: entries[0].metadata.cardinality,\n        bindOrder: this.bindOrder,\n      },\n    };\n  }\n\n  public canBindWithOperation(operation: Algebra.Operation): boolean {\n    let valid = true;\n    Util.recurseOperation(operation, {\n      [Algebra.types.EXTEND](): boolean {\n        valid = false;\n        return false;\n      },\n      [Algebra.types.GROUP](): boolean {\n        valid = false;\n        return false;\n      },\n    });\n\n    return valid;\n  }\n\n  public async getJoinCoefficients(\n    action: IActionRdfJoin,\n    sideData: IActorRdfJoinTestSideData,\n  ): Promise<TestResult<IMediatorTypeJoinCoefficients, IActorRdfJoinMultiBindTestSideData>> {\n    let { metadatas } = sideData;\n\n    // Order the entries so we can pick the first one (usually the one with the lowest cardinality)\n    const entriesUnsorted = action.entries\n      .map((entry, i) => ({ ...entry, metadata: metadatas[i] }));\n    const entriesTest = await ActorRdfJoin\n      .sortJoinEntries(this.mediatorJoinEntriesSort, entriesUnsorted, action.context);\n    if (entriesTest.isFailed()) {\n      return entriesTest;\n    }\n    const entriesSorted = entriesTest.get();\n    metadatas = entriesSorted.map(entry => entry.metadata);\n\n    const requestInitialTimes = ActorRdfJoin.getRequestInitialTimes(metadatas);\n    const requestItemTimes = ActorRdfJoin.getRequestItemTimes(metadatas);\n\n    // Determine first stream and remaining ones\n    const remainingEntries = [ ...entriesSorted ];\n    const remainingRequestInitialTimes = [ ...requestInitialTimes ];\n    const remainingRequestItemTimes = [ ...requestItemTimes ];\n    remainingEntries.splice(0, 1);\n    remainingRequestInitialTimes.splice(0, 1);\n    remainingRequestItemTimes.splice(0, 1);\n\n    // Reject binding on some operation types\n    if (remainingEntries\n      .some(entry => !this.canBindWithOperation(entry.operation))) {\n      return failTest(`Actor ${this.name} can not bind on Extend and Group operations`);\n    }\n\n    // Reject binding on modified operations, since using the output directly would be significantly more efficient.\n    if (remainingEntries.some(entry => entry.operationModified)) {\n      return failTest(`Actor ${this.name} can not be used over remaining entries with modified operations`);\n    }\n\n    // Only run this actor if the smallest stream is significantly smaller than the largest stream.\n    // We must use Math.max, because the last metadata is not necessarily the biggest, but it's the least preferred.\n    // If join entries are produced locally, we increase the possibility of doing this bind join, as it's cheap.\n    const isRemoteAccess = requestItemTimes.some(time => time > 0);\n    if (metadatas[0].cardinality.value * this.minMaxCardinalityRatio / (isRemoteAccess ? 1 : 3) >\n      Math.max(...metadatas.map(metadata => metadata.cardinality.value))) {\n      return failTest(`Actor ${this.name} can only run if the smallest stream is much smaller than largest stream`);\n    }\n\n    // Determine selectivities of smallest entry with all other entries\n    const selectivities = await Promise.all(remainingEntries\n      .map(async entry => (await this.mediatorJoinSelectivity.mediate({\n        entries: [ entriesSorted[0], entry ],\n        context: action.context,\n      })).selectivity * this.selectivityModifier));\n\n    // Determine coefficients for remaining entries\n    const cardinalityRemaining = remainingEntries\n      .map((entry, i) => entry.metadata.cardinality.value * selectivities[i])\n      .reduce((sum, element) => sum + element, 0);\n    const receiveInitialCostRemaining = remainingRequestInitialTimes\n      .reduce((sum, element) => sum + element, 0);\n    const receiveItemCostRemaining = remainingRequestItemTimes\n      .reduce((sum, element) => sum + element, 0);\n\n    return passTestWithSideData({\n      iterations: metadatas[0].cardinality.value * cardinalityRemaining,\n      persistedItems: 0,\n      blockingItems: 0,\n      requestTime: requestInitialTimes[0] +\n        metadatas[0].cardinality.value * (\n          requestItemTimes[0] +\n          receiveInitialCostRemaining +\n          cardinalityRemaining * receiveItemCostRemaining\n        ),\n    }, { ...sideData, entriesUnsorted, entriesSorted });\n  }\n}\n\nexport interface IActorRdfJoinMultiBindArgs extends IActorRdfJoinArgs<IActorRdfJoinMultiBindTestSideData> {\n  /**\n   * The order in which elements should be bound\n   * @default {depth-first}\n   */\n  bindOrder: BindOrder;\n  /**\n   * Multiplier for selectivity values\n   * @range {double}\n   * @default {0.0001}\n   */\n  selectivityModifier: number;\n  /**\n   * The number of times the smallest cardinality should fit in the maximum cardinality.\n   * @range {double}\n   * @default {60}\n   */\n  minMaxCardinalityRatio: number;\n  /**\n   * The join entries sort mediator\n   */\n  mediatorJoinEntriesSort: MediatorRdfJoinEntriesSort;\n  /**\n   * The query operation mediator\n   */\n  mediatorQueryOperation: MediatorQueryOperation;\n  /**\n   * A mediator for creating binding context merge handlers\n   */\n  mediatorMergeBindingsContext: MediatorMergeBindingsContext;\n}\n\nexport type BindOrder = 'depth-first' | 'breadth-first';\n\nexport interface IActorRdfJoinMultiBindTestSideData extends IActorRdfJoinTestSideData {\n  entriesUnsorted: IJoinEntryWithMetadata[];\n  entriesSorted: IJoinEntryWithMetadata[];\n}\n"]}
{"version":3,"file":"AlgebraTransformer.js","sourceRoot":"","sources":["AlgebraTransformer.ts"],"names":[],"mappings":"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","sourcesContent":["import type { MediatorFunctionFactory } from '@comunica/bus-function-factory';\nimport { KeysExpressionEvaluator } from '@comunica/context-entries';\nimport type { Expression, IActionContext, OperatorExpression } from '@comunica/types';\nimport * as ExprEval from '@comunica/utils-expression-evaluator';\nimport { Algebra as Alg } from 'sparqlalgebrajs';\n\nexport class AlgebraTransformer extends ExprEval.TermTransformer {\n  public constructor(\n    private readonly context: IActionContext,\n    private readonly mediatorFunctionFactory: MediatorFunctionFactory,\n  ) {\n    super(context.getSafe(KeysExpressionEvaluator.superTypeProvider));\n  }\n\n  public async transformAlgebra(expr: Alg.Expression): Promise<Expression> {\n    const types = Alg.expressionTypes;\n\n    switch (expr.expressionType) {\n      case types.TERM:\n        return this.transformTerm(expr);\n      case types.OPERATOR:\n        return await this.transformOperator(expr);\n      case types.NAMED:\n        return await this.transformNamed(expr);\n      case types.EXISTENCE:\n        return AlgebraTransformer.transformExistence(expr);\n      case types.AGGREGATE:\n        return AlgebraTransformer.transformAggregate(expr);\n      case types.WILDCARD:\n        return AlgebraTransformer.transformWildcard(expr);\n    }\n  }\n\n  private static transformWildcard(term: Alg.WildcardExpression): Expression {\n    return new ExprEval.NamedNode(term.wildcard.value);\n  }\n\n  private async getOperator(operator: string, expr: Alg.OperatorExpression | Alg.NamedExpression):\n  Promise<OperatorExpression> {\n    const operatorFunc = await this.mediatorFunctionFactory.mediate({\n      functionName: operator,\n      arguments: expr.args,\n      context: this.context,\n    });\n    const operatorArgs = await Promise.all(expr.args.map(arg => this.transformAlgebra(arg)));\n    if (!operatorFunc.checkArity(operatorArgs)) {\n      throw new ExprEval.InvalidArity(operatorArgs, operator);\n    }\n    return new ExprEval.Operator(operator, operatorArgs, operatorFunc.apply);\n  }\n\n  private async transformOperator(expr: Alg.OperatorExpression): Promise<OperatorExpression> {\n    return this.getOperator(expr.operator.toLowerCase(), expr);\n  }\n\n  private async transformNamed(expr: Alg.NamedExpression): Promise<OperatorExpression> {\n    return this.getOperator(expr.name.value, expr);\n  }\n\n  public static transformAggregate(expr: Alg.AggregateExpression): ExprEval.Aggregate {\n    const name = expr.aggregator;\n    return new ExprEval.Aggregate(name, expr);\n  }\n\n  public static transformExistence(expr: Alg.ExistenceExpression): ExprEval.Existence {\n    return new ExprEval.Existence(expr);\n  }\n}\n"]}
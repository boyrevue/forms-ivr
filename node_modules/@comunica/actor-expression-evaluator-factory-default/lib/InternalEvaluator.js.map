{"version":3,"file":"InternalEvaluator.js","sourceRoot":"","sources":["InternalEvaluator.ts"],"names":[],"mappings":"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","sourcesContent":["import type { MediatorFunctionFactory } from '@comunica/bus-function-factory';\nimport type { MediatorQueryOperation } from '@comunica/bus-query-operation';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type { ComunicaDataFactory, Expression, IActionContext, TermExpression } from '@comunica/types';\nimport { ExpressionType } from '@comunica/types';\nimport type { BindingsFactory } from '@comunica/utils-bindings-factory';\nimport * as Eval from '@comunica/utils-expression-evaluator';\nimport { getSafeBindings, materializeOperation } from '@comunica/utils-query-operation';\nimport type * as RDF from '@rdfjs/types';\nimport { Factory } from 'sparqlalgebrajs';\nimport { AlgebraTransformer } from './AlgebraTransformer';\n\n/**\n * This class provides evaluation functionality to already transformed expressions.\n */\nexport class InternalEvaluator {\n  public readonly transformer: AlgebraTransformer;\n\n  private readonly subEvaluators:\n  Record<ExpressionType, (expr: Expression, mapping: RDF.Bindings) => Promise<Eval.Term> | Eval.Term> =\n      {\n        [ExpressionType.Term]: (expr, _mapping) => this.term(<Eval.Term> expr),\n        [ExpressionType.Variable]: (expr, mapping) => this.variable(<Eval.Variable> expr, mapping),\n        [ExpressionType.Operator]: (expr, mapping) => this.evalFunction(<Eval.Operator> expr, mapping),\n        [ExpressionType.Existence]: (expr, mapping) => this.evalExistence(<Eval.Existence> expr, mapping),\n        [ExpressionType.Aggregate]: (_expr, _mapping) => this.evalAggregate(),\n      };\n\n  public constructor(\n    public readonly context: IActionContext,\n    mediatorFunctionFactory: MediatorFunctionFactory,\n    private readonly mediatorQueryOperation: MediatorQueryOperation,\n    private readonly bindingsFactory: BindingsFactory,\n  ) {\n    this.transformer = new AlgebraTransformer(\n      context,\n      mediatorFunctionFactory,\n    );\n  }\n\n  public async evaluatorExpressionEvaluation(expr: Expression, mapping: RDF.Bindings): Promise<TermExpression> {\n    const evaluator = this.subEvaluators[expr.expressionType];\n    return evaluator.bind(this)(expr, mapping);\n  }\n\n  private term(expr: Eval.Term): Eval.Term {\n    return expr;\n  }\n\n  private variable(expr: Eval.Variable, mapping: RDF.Bindings): Eval.Term {\n    const term = mapping.get(Eval.expressionToVar(this.context.getSafe(KeysInitQuery.dataFactory), expr));\n    if (!term) {\n      throw new Eval.UnboundVariableError(expr.name, mapping);\n    }\n    return this.transformer.transformRDFTermUnsafe(term);\n  }\n\n  private async evalFunction(expr: Eval.Operator, mapping: RDF.Bindings):\n  Promise<Eval.Term> {\n    return expr.apply({\n      args: expr.args,\n      mapping,\n      exprEval: this,\n    });\n  }\n\n  private async evalExistence(expr: Eval.Existence, mapping: RDF.Bindings): Promise<Eval.Term> {\n    const dataFactory: ComunicaDataFactory = this.context.getSafe(KeysInitQuery.dataFactory);\n    const algebraFactory = new Factory(dataFactory);\n    const operation = materializeOperation(expr.expression.input, mapping, algebraFactory, this.bindingsFactory);\n\n    const outputRaw = await this.mediatorQueryOperation.mediate({ operation, context: this.context });\n    const output = getSafeBindings(outputRaw);\n\n    return await new Promise<boolean>(\n      (resolve, reject) => {\n        output.bindingsStream.on('end', () => {\n          resolve(false);\n        });\n\n        output.bindingsStream.on('error', reject);\n\n        output.bindingsStream.on('data', () => {\n          output.bindingsStream.close();\n          resolve(true);\n        });\n      },\n    )\n      .then((exists: boolean) => expr.expression.not ? !exists : exists)\n      .then((exists: boolean) => new Eval.BooleanLiteral(exists));\n  }\n\n  private evalAggregate(): never {\n    throw new Eval.NoAggregator();\n  }\n}\n"]}
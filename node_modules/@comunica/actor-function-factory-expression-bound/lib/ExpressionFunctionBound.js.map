{"version":3,"file":"ExpressionFunctionBound.js","sourceRoot":"","sources":["ExpressionFunctionBound.ts"],"names":[],"mappings":";;;AAAA,yEAAwE;AACxE,+DAA0D;AAE1D,2CAAiD;AACjD,qFAK8C;AAE9C;;;GAGG;AACH,MAAa,uBAAwB,SAAQ,6CAAsB;IACjE;QACE,KAAK,CAAC;YACJ,KAAK,EAAE,CAAC;YACR,QAAQ,EAAE,2CAAc,CAAC,KAAK;YAC9B,KAAK,EAAE,KAAK,EAAC,EAAE,IAAI,EAAE,OAAO,EAAE,QAAQ,EAAgB,EAA2B,EAAE;gBACjF,MAAM,QAAQ,GAAwB,IAAI,CAAC,CAAC,CAAC,CAAC;gBAC9C,IAAI,QAAQ,CAAC,cAAc,KAAK,sBAAc,CAAC,QAAQ,EAAE,CAAC;oBACxD,MAAM,IAAI,iDAAoB,CAAC,IAAI,EAAE,2CAAc,CAAC,KAAK,CAAC,CAAC;gBAC7D,CAAC;gBACD,MAAM,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,IAAA,4CAAe,EAAC,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,+BAAa,CAAC,WAAW,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC;gBACxG,OAAO,IAAA,iCAAI,EAAC,GAAG,CAAC,CAAC;YACnB,CAAC;SACF,CAAC,CAAC;IACL,CAAC;CACF;AAfD,0DAeC","sourcesContent":["import { ExpressionFunctionBase } from '@comunica/bus-function-factory';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type { IEvalContext, TermExpression, VariableExpression } from '@comunica/types';\nimport { ExpressionType } from '@comunica/types';\nimport {\n  bool,\n  expressionToVar,\n  InvalidArgumentTypes,\n  SparqlOperator,\n} from '@comunica/utils-expression-evaluator';\n\n/**\n * https://www.w3.org/TR/sparql11-query/#func-bound\n * This function doesn't require type promotion or subtype-substitution, everything works on TermExpression\n */\nexport class ExpressionFunctionBound extends ExpressionFunctionBase {\n  public constructor() {\n    super({\n      arity: 1,\n      operator: SparqlOperator.BOUND,\n      apply: async({ args, mapping, exprEval }: IEvalContext): Promise<TermExpression> => {\n        const variable = <VariableExpression> args[0];\n        if (variable.expressionType !== ExpressionType.Variable) {\n          throw new InvalidArgumentTypes(args, SparqlOperator.BOUND);\n        }\n        const val = mapping.has(expressionToVar(exprEval.context.getSafe(KeysInitQuery.dataFactory), variable));\n        return bool(val);\n      },\n    });\n  }\n}\n"]}
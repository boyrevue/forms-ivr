{"version":3,"file":"TermComparatorExpressionEvaluator.js","sourceRoot":"","sources":["TermComparatorExpressionEvaluator.ts"],"names":[],"mappings":"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","sourcesContent":["import type { InternalEvaluator } from '@comunica/actor-expression-evaluator-factory-default/lib/InternalEvaluator';\nimport type { ITermFunction } from '@comunica/bus-function-factory';\nimport type { ITermComparator } from '@comunica/bus-term-comparator-factory';\nimport type * as Eval from '@comunica/utils-expression-evaluator';\nimport type * as RDF from '@rdfjs/types';\n\nexport class TermComparatorExpressionEvaluator implements ITermComparator {\n  public constructor(\n    private readonly internalEvaluator: InternalEvaluator,\n    private readonly equalityFunction: ITermFunction,\n    private readonly lessThanFunction: ITermFunction,\n  ) {}\n\n  // Determine the relative numerical order of the two given terms.\n  // In accordance with https://www.w3.org/TR/sparql11-query/#modOrderBy\n  public orderTypes(termA: RDF.Term | undefined, termB: RDF.Term | undefined): -1 | 0 | 1 {\n    // Check if terms are the same by reference\n    if (termA === termB) {\n      return 0;\n    }\n\n    // We handle undefined that is lower than everything else.\n    if (termA === undefined) {\n      return -1;\n    }\n    if (termB === undefined) {\n      return 1;\n    }\n\n    //\n    if (termA.termType !== termB.termType) {\n      return this._TERM_ORDERING_PRIORITY[termA.termType] < this._TERM_ORDERING_PRIORITY[termB.termType] ? -1 : 1;\n    }\n\n    // Check exact term equality\n    if (termA.equals(termB)) {\n      return 0;\n    }\n\n    // Handle quoted triples\n    if (termA.termType === 'Quad' && termB.termType === 'Quad') {\n      const orderSubject = this.orderTypes(\n        termA.subject,\n        termB.subject,\n      );\n      if (orderSubject !== 0) {\n        return orderSubject;\n      }\n      const orderPredicate = this.orderTypes(\n        termA.predicate,\n        termB.predicate,\n      );\n      if (orderPredicate !== 0) {\n        return orderPredicate;\n      }\n      const orderObject = this.orderTypes(\n        termA.object,\n        termB.object,\n      );\n      if (orderObject !== 0) {\n        return orderObject;\n      }\n      return this.orderTypes(\n        termA.graph,\n        termB.graph,\n      );\n    }\n\n    // Handle literals\n    if (termA.termType === 'Literal') {\n      return this.orderLiteralTypes(termA, <RDF.Literal>termB);\n    }\n\n    return this.comparePrimitives(termA.value, termB.value);\n  }\n\n  private orderLiteralTypes(litA: RDF.Literal, litB: RDF.Literal): -1 | 0 | 1 {\n    const myLitA: Eval.Literal<any> = this.internalEvaluator.transformer.transformLiteral(litA);\n    const myLitB: Eval.Literal<any> = this.internalEvaluator.transformer.transformLiteral(litB);\n\n    try {\n      if ((<Eval.BooleanLiteral> this.equalityFunction.applyOnTerms([ myLitA, myLitB ], this.internalEvaluator))\n        .typedValue) {\n        return 0;\n      }\n      if ((<Eval.BooleanLiteral> this.lessThanFunction.applyOnTerms([ myLitA, myLitB ], this.internalEvaluator))\n        .typedValue) {\n        return -1;\n      }\n      return 1;\n    } catch {\n      // Fallback to string-based comparison\n      const compareType = this.comparePrimitives(myLitA.dataType, myLitB.dataType);\n      if (compareType !== 0) {\n        return compareType;\n      }\n      return this.comparePrimitives(myLitA.str(), myLitB.str());\n    }\n  }\n\n  private comparePrimitives(valueA: any, valueB: any): -1 | 0 | 1 {\n    return valueA === valueB ? 0 : (valueA < valueB ? -1 : 1);\n  }\n\n  // SPARQL specifies that blankNode < namedNode < literal. Sparql star expands with < quads and we say < defaultGraph\n  private readonly _TERM_ORDERING_PRIORITY = {\n    Variable: 0,\n    BlankNode: 1,\n    NamedNode: 2,\n    Literal: 3,\n    Quad: 4,\n    DefaultGraph: 5,\n  };\n}\n"]}
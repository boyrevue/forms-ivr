{"version":3,"file":"ActorRdfMetadataExtractSparqlService.js","sourceRoot":"","sources":["ActorRdfMetadataExtractSparqlService.ts"],"names":[],"mappings":";;;AAKA,iFAA6E;AAE7E,yCAA8C;AAE9C,uEAAiE;AAEjE;;GAEG;AACH,MAAa,oCAAqC,SAAQ,kDAAuB;IAG/E,YAAmB,IAA+C;QAChE,KAAK,CAAC,IAAI,CAAC,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,OAAkC;QAClD,OAAO,IAAA,mBAAY,GAAE,CAAC;IACxB,CAAC;IAEM,KAAK,CAAC,GAAG,CAAC,MAAiC;QAChD,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACrC,iBAAiB;YACjB,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;YAEpC,6EAA6E;YAC7E,MAAM,iBAAiB,GAAG,IAAI,GAAG,CAAS,CAAE,MAAM,CAAC,GAAG,CAAE,CAAC,CAAC;YAE1D,MAAM,QAAQ,GAAgD,EAAE,CAAC;YACjE,MAAM,YAAY,GAAG,IAAI,GAAG,EAAU,CAAC;YACvC,MAAM,aAAa,GAAG,IAAI,GAAG,EAAU,CAAC;YACxC,MAAM,kBAAkB,GAAG,IAAI,GAAG,EAAU,CAAC;YAE7C,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAc,EAAE,EAAE;gBAC5C,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,KAAK,gCAAgC,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,KAAK,MAAM,CAAC,GAAG,EAAE,CAAC;oBAClG,mGAAmG;oBACnG,oFAAoF;oBACpF,oGAAoG;oBACpG,sFAAsF;oBACtF,iBAAiB,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;gBAC5C,CAAC;qBAAM,IACL,IAAI,CAAC,OAAO,CAAC,KAAK,KAAK,QAAQ,CAAC,cAAc;oBAC9C,IAAI,CAAC,OAAO,CAAC,QAAQ,KAAK,WAAW;oBACrC,iBAAiB,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,EACzC,CAAC;oBACD,QAAQ,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;wBAC7B,KAAK,0DAA0D;4BAC7D,uGAAuG;4BACvG,6FAA6F;4BAC7F,QAAQ,CAAC,aAAa,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,KAAK,SAAS,CAAC,CAAC;gCAC3D,IAAA,kCAAU,EAAC,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;gCAC3C,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC;4BACpB,yGAAyG;4BACzG,IAAI,IAAI,CAAC,kBAAkB,IAAI,MAAM,CAAC,GAAG,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE,CAAC;gCACxG,QAAQ,CAAC,aAAa,GAAG,QAAQ,CAAC,aAAa,CAAC,OAAO,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;4BAC/E,CAAC;4BACD,MAAM;wBACR,KAAK,gEAAgE;4BACnE,QAAQ,CAAC,cAAc,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC;4BAC5C,MAAM;wBACR,KAAK,8DAA8D;4BACjE,QAAQ,CAAC,YAAY,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC;4BAC1C,MAAM;wBACR,KAAK,6DAA6D;4BAChE,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;4BACpC,MAAM;wBACR,KAAK,8DAA8D;4BACjE,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;4BACrC,MAAM;wBACR,KAAK,mEAAmE;4BACtE,kBAAkB,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;4BAC1C,MAAM;wBACR,KAAK,yDAAyD;4BAC5D,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,KAAK,mEAAmE,EAAE,CAAC;gCAC9F,QAAQ,CAAC,iBAAiB,GAAG,IAAI,CAAC;4BACpC,CAAC;iCAAM,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,KAAK,qEAAqE,EAAE,CAAC;gCACvG,QAAQ,CAAC,mBAAmB,GAAG,IAAI,CAAC;4BACtC,CAAC;4BACD,MAAM;oBACV,CAAC;gBACH,CAAC;YACH,CAAC,CAAC,CAAC;YAEH,6DAA6D;YAC7D,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE;gBAC7B,OAAO,CAAC,EAAE,QAAQ,EAAE;wBAClB,GAAG,QAAQ;wBACX,GAAG,YAAY,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,YAAY,EAAE,CAAE,GAAG,YAAY,CAAC,MAAM,EAAE,CAAE,EAAC,CAAC,CAAC,CAAC,EAAE;wBAC7E,GAAG,aAAa,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,aAAa,EAAE,CAAE,GAAG,aAAa,CAAC,MAAM,EAAE,CAAE,EAAC,CAAC,CAAC,CAAC,EAAE;wBAChF,GAAG,kBAAkB,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,kBAAkB,EAAE,CAAE,GAAG,kBAAkB,CAAC,MAAM,EAAE,CAAE,EAAC,CAAC,CAAC,CAAC,EAAE;qBAChG,EAAC,CAAC,CAAC;YACN,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;CACF;AArFD,oFAqFC","sourcesContent":["import type {\n  IActionRdfMetadataExtract,\n  IActorRdfMetadataExtractOutput,\n  IActorRdfMetadataExtractArgs,\n} from '@comunica/bus-rdf-metadata-extract';\nimport { ActorRdfMetadataExtract } from '@comunica/bus-rdf-metadata-extract';\nimport type { IActorTest, TestResult } from '@comunica/core';\nimport { passTestVoid } from '@comunica/core';\nimport type * as RDF from '@rdfjs/types';\nimport { resolve as resolveIri } from 'relative-to-absolute-iri';\n\n/**\n * Comunica RDF metadata extract actor for SPARQL Service Descriptions.\n */\nexport class ActorRdfMetadataExtractSparqlService extends ActorRdfMetadataExtract {\n  private readonly inferHttpsEndpoint: boolean;\n\n  public constructor(args: IActorRdfMetadataExtractSparqlServiceArgs) {\n    super(args);\n  }\n\n  public async test(_action: IActionRdfMetadataExtract): Promise<TestResult<IActorTest>> {\n    return passTestVoid();\n  }\n\n  public async run(action: IActionRdfMetadataExtract): Promise<IActorRdfMetadataExtractOutput> {\n    return new Promise((resolve, reject) => {\n      // Forward errors\n      action.metadata.on('error', reject);\n\n      // Filter the subject URIs to consider, to avoid picking up unrelated entries\n      const acceptSubjectUris = new Set<string>([ action.url ]);\n\n      const metadata: Record<string, string | string[] | boolean> = {};\n      const inputFormats = new Set<string>();\n      const resultFormats = new Set<string>();\n      const supportedLanguages = new Set<string>();\n\n      action.metadata.on('data', (quad: RDF.Quad) => {\n        if (quad.predicate.value === 'http://rdfs.org/ns/void#subset' && quad.object.value === action.url) {\n          // When the requested URI is a subset of another dataset, as indicated by this predicate, then also\n          // consider that other dataset for the extraction of the following predicate values.\n          // This works an issue with Quad Pattern Fragments that has the sd:defaultGraph predicate associated\n          // with a subject value that is neither the data source URI nor the sd:defaultDataset.\n          acceptSubjectUris.add(quad.subject.value);\n        } else if (\n          quad.subject.value === metadata.defaultDataset ||\n          quad.subject.termType === 'BlankNode' ||\n          acceptSubjectUris.has(quad.subject.value)\n        ) {\n          switch (quad.predicate.value) {\n            case 'http://www.w3.org/ns/sparql-service-description#endpoint':\n              // The VoID specification defines this as IRI, but does not specify whether or not it can be a literal.\n              // When the IRI is a literal, it can be relative, and needs to be resolved to absolute value.\n              metadata.sparqlService = quad.object.termType === 'Literal' ?\n                resolveIri(quad.object.value, action.url) :\n                quad.object.value;\n              // Also fix a common mistake in SPARQL endpoint setups where HTTPS SD's refer to a non-existing HTTP API.\n              if (this.inferHttpsEndpoint && action.url.startsWith('https') && !quad.object.value.startsWith('https')) {\n                metadata.sparqlService = metadata.sparqlService.replace(/^http:/u, 'https:');\n              }\n              break;\n            case 'http://www.w3.org/ns/sparql-service-description#defaultDataset':\n              metadata.defaultDataset = quad.object.value;\n              break;\n            case 'http://www.w3.org/ns/sparql-service-description#defaultGraph':\n              metadata.defaultGraph = quad.object.value;\n              break;\n            case 'http://www.w3.org/ns/sparql-service-description#inputFormat':\n              inputFormats.add(quad.object.value);\n              break;\n            case 'http://www.w3.org/ns/sparql-service-description#resultFormat':\n              resultFormats.add(quad.object.value);\n              break;\n            case 'http://www.w3.org/ns/sparql-service-description#supportedLanguage':\n              supportedLanguages.add(quad.object.value);\n              break;\n            case 'http://www.w3.org/ns/sparql-service-description#feature':\n              if (quad.object.value === 'http://www.w3.org/ns/sparql-service-description#UnionDefaultGraph') {\n                metadata.unionDefaultGraph = true;\n              } else if (quad.object.value === 'http://www.w3.org/ns/sparql-service-description#BasicFederatedQuery') {\n                metadata.basicFederatedQuery = true;\n              }\n              break;\n          }\n        }\n      });\n\n      // Only return the metadata if an endpoint IRI was discovered\n      action.metadata.on('end', () => {\n        resolve({ metadata: {\n          ...metadata,\n          ...inputFormats.size > 0 ? { inputFormats: [ ...inputFormats.values() ]} : {},\n          ...resultFormats.size > 0 ? { resultFormats: [ ...resultFormats.values() ]} : {},\n          ...supportedLanguages.size > 0 ? { supportedLanguages: [ ...supportedLanguages.values() ]} : {},\n        }});\n      });\n    });\n  }\n}\n\nexport interface IActorRdfMetadataExtractSparqlServiceArgs extends IActorRdfMetadataExtractArgs {\n  /**\n   * If HTTPS endpoints should be forcefully used if the original URL was HTTPS-based\n   * @default {true}\n   */\n  inferHttpsEndpoint: boolean;\n}\n"]}
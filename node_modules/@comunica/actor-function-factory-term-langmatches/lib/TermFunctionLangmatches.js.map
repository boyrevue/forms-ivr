{"version":3,"file":"TermFunctionLangmatches.js","sourceRoot":"","sources":["TermFunctionLangmatches.ts"],"names":[],"mappings":";;;AAAA,yEAAkE;AAElE,qFAK8C;AAE9C;;GAEG;AACH,MAAa,uBAAwB,SAAQ,uCAAgB;IAC3D;QACE,KAAK,CAAC;YACJ,KAAK,EAAE,CAAC;YACR,QAAQ,EAAE,2CAAc,CAAC,YAAY;YACrC,SAAS,EAAE,IAAA,oCAAO,EAAC,2CAAc,CAAC,YAAY,CAAC;iBAC5C,aAAa,CACZ,CAAE,oCAAO,CAAC,UAAU,EAAE,oCAAO,CAAC,UAAU,CAAE,EAC1C,GAAG,EAAE,CAAC,CAAC,GAAW,EAAE,KAAa,EAAE,EAAE,CAAC,IAAA,iCAAI,EAAC,uBAAuB,CAAC,WAAW,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,CAC5F,CAAC,OAAO,EAAE;SACd,CAAC,CAAC;IACL,CAAC;IAED,8BAA8B;IAC9B,2BAA2B;IAC3B,uCAAuC;IACvC,yDAAyD;IACjD,MAAM,CAAC,WAAW,CAAC,GAAW,EAAE,KAAa;QACnD,MAAM,QAAQ,GAAG,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAChC,MAAM,SAAS,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAEnC,IAAI,CAAC,uBAAuB,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;YAClE,CAAC,uBAAuB,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;YACnD,OAAO,KAAK,CAAC;QACf,CAAC;QAED,IAAI,EAAE,GAAG,CAAC,CAAC;QACX,IAAI,EAAE,GAAG,CAAC,CAAC;QACX,OAAO,EAAE,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC;YAC7B,IAAI,uBAAuB,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;gBACtD,EAAE,EAAE,CAAC;gBACL,SAAS;YACX,CAAC;YACD,IAAI,EAAE,KAAK,QAAQ,CAAC,MAAM,EAAE,CAAC;gBAC3B,OAAO,KAAK,CAAC;YACf,CAAC;YACD,IAAI,uBAAuB,CAAC,YAAY,CAAC,SAAS,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;gBACtE,EAAE,EAAE,CAAC;gBACL,EAAE,EAAE,CAAC;gBACL,SAAS;YACX,CAAC;YACD,IAAI,QAAQ,CAAC,EAAE,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;gBAC9B,OAAO,KAAK,CAAC;YACf,CAAC;YACD,EAAE,EAAE,CAAC;QACP,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAEO,MAAM,CAAC,UAAU,CAAC,GAAW;QACnC,OAAO,GAAG,KAAK,GAAG,CAAC;IACrB,CAAC;IAEO,MAAM,CAAC,YAAY,CAAC,IAAY,EAAE,KAAa;QACrD,MAAM,YAAY,GAAG,IAAI,MAAM,CAAC,IAAI,IAAI,GAAG,EAAE,IAAI,CAAC,CAAC;QACnD,OAAO,YAAY,CAAC,IAAI,CAAC,IAAI,KAAK,GAAG,CAAC,CAAC;IACzC,CAAC;CACF;AAzDD,0DAyDC","sourcesContent":["import { TermFunctionBase } from '@comunica/bus-function-factory';\n\nimport {\n  bool,\n  declare,\n  SparqlOperator,\n  TypeURL,\n} from '@comunica/utils-expression-evaluator';\n\n/**\n * https://www.w3.org/TR/sparql11-query/#func-langMatches\n */\nexport class TermFunctionLangmatches extends TermFunctionBase {\n  public constructor() {\n    super({\n      arity: 2,\n      operator: SparqlOperator.LANG_MATCHES,\n      overloads: declare(SparqlOperator.LANG_MATCHES)\n        .onBinaryTyped(\n          [ TypeURL.XSD_STRING, TypeURL.XSD_STRING ],\n          () => (tag: string, range: string) => bool(TermFunctionLangmatches.langMatches(tag, range)),\n        ).collect(),\n    });\n  }\n\n  // TODO: Not an XPath function\n  // TODO: Publish as package\n  // https://www.ietf.org/rfc/rfc4647.txt\n  // https://www.w3.org/TR/sparql11-query/#func-langMatches\n  private static langMatches(tag: string, range: string): boolean {\n    const langTags = tag.split('-');\n    const rangeTags = range.split('-');\n\n    if (!TermFunctionLangmatches.matchLangTag(rangeTags[0], langTags[0]) &&\n      !TermFunctionLangmatches.isWildCard(langTags[0])) {\n      return false;\n    }\n\n    let lI = 1;\n    let rI = 1;\n    while (rI < rangeTags.length) {\n      if (TermFunctionLangmatches.isWildCard(rangeTags[rI])) {\n        rI++;\n        continue;\n      }\n      if (lI === langTags.length) {\n        return false;\n      }\n      if (TermFunctionLangmatches.matchLangTag(rangeTags[rI], langTags[lI])) {\n        lI++;\n        rI++;\n        continue;\n      }\n      if (langTags[lI].length === 1) {\n        return false;\n      }\n      lI++;\n    }\n    return true;\n  }\n\n  private static isWildCard(tag: string): boolean {\n    return tag === '*';\n  }\n\n  private static matchLangTag(left: string, right: string): boolean {\n    const matchInitial = new RegExp(`/${left}/`, 'iu');\n    return matchInitial.test(`/${right}/`);\n  }\n}\n"]}
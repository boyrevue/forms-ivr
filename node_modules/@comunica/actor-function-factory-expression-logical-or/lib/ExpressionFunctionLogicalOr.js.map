{"version":3,"file":"ExpressionFunctionLogicalOr.js","sourceRoot":"","sources":["ExpressionFunctionLogicalOr.ts"],"names":[],"mappings":";;;AAAA,yEAAwE;AAExE,qFAG8C;AAE9C;;;GAGG;AACH,MAAa,2BAA4B,SAAQ,6CAAsB;IACrE;QACE,KAAK,CAAC;YACJ,KAAK,EAAE,CAAC;YACR,QAAQ,EAAE,2CAAc,CAAC,UAAU;YACnC,KAAK,EAAE,KAAK,EAAC,EAAE,IAAI,EAAE,OAAO,EAAE,QAAQ,EAAgB,EAA2B,EAAE;gBACjF,MAAM,CAAE,QAAQ,EAAE,SAAS,CAAE,GAAG,IAAI,CAAC;gBACrC,IAAI,CAAC;oBACH,MAAM,QAAQ,GAAG,MAAM,QAAQ,CAAC,6BAA6B,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;oBACjF,MAAM,IAAI,GAAG,QAAQ,CAAC,SAAS,EAAE,CAAC;oBAClC,IAAI,IAAI,EAAE,CAAC;wBACT,OAAO,IAAA,iCAAI,EAAC,IAAI,CAAC,CAAC;oBACpB,CAAC;oBACD,MAAM,SAAS,GAAG,MAAM,QAAQ,CAAC,6BAA6B,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;oBACnF,MAAM,KAAK,GAAG,SAAS,CAAC,SAAS,EAAE,CAAC;oBACpC,OAAO,IAAA,iCAAI,EAAC,KAAK,CAAC,CAAC;gBACrB,CAAC;gBAAC,OAAO,KAAc,EAAE,CAAC;oBACxB,MAAM,cAAc,GAAG,MAAM,QAAQ,CAAC,6BAA6B,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;oBACxF,MAAM,UAAU,GAAG,cAAc,CAAC,SAAS,EAAE,CAAC;oBAC9C,IAAI,CAAC,UAAU,EAAE,CAAC;wBAChB,MAAM,KAAK,CAAC;oBACd,CAAC;oBACD,OAAO,IAAA,iCAAI,EAAC,IAAI,CAAC,CAAC;gBACpB,CAAC;YACH,CAAC;SACF,CAAC,CAAC;IACL,CAAC;CACF;AA3BD,kEA2BC","sourcesContent":["import { ExpressionFunctionBase } from '@comunica/bus-function-factory';\nimport type { IEvalContext, TermExpression } from '@comunica/types';\nimport {\n  bool,\n  SparqlOperator,\n} from '@comunica/utils-expression-evaluator';\n\n/**\n * https://www.w3.org/TR/sparql11-query/#func-logical-or\n * This function doesn't require type promotion or subtype-substitution, everything works on TermExpression\n */\nexport class ExpressionFunctionLogicalOr extends ExpressionFunctionBase {\n  public constructor() {\n    super({\n      arity: 2,\n      operator: SparqlOperator.LOGICAL_OR,\n      apply: async({ args, mapping, exprEval }: IEvalContext): Promise<TermExpression> => {\n        const [ leftExpr, rightExpr ] = args;\n        try {\n          const leftTerm = await exprEval.evaluatorExpressionEvaluation(leftExpr, mapping);\n          const left = leftTerm.coerceEBV();\n          if (left) {\n            return bool(true);\n          }\n          const rightTerm = await exprEval.evaluatorExpressionEvaluation(rightExpr, mapping);\n          const right = rightTerm.coerceEBV();\n          return bool(right);\n        } catch (error: unknown) {\n          const rightErrorTerm = await exprEval.evaluatorExpressionEvaluation(rightExpr, mapping);\n          const rightError = rightErrorTerm.coerceEBV();\n          if (!rightError) {\n            throw error;\n          }\n          return bool(true);\n        }\n      },\n    });\n  }\n}\n"]}
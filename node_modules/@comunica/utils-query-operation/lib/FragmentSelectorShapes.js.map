{"version":3,"file":"FragmentSelectorShapes.js","sourceRoot":"","sources":["FragmentSelectorShapes.ts"],"names":[],"mappings":"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","sourcesContent":["import type { FragmentSelectorShape } from '@comunica/types';\nimport type { Algebra } from 'sparqlalgebrajs';\n\n/**\n * Check if the given shape accepts the given query operation.\n * @param shape A shape to test the query operation against.\n * @param operation A query operation to test.\n * @param options Additional options to consider.\n * @param options.joinBindings If additional bindings will be pushed down to the source for joining.\n * @param options.filterBindings If additional bindings will be pushed down to the source for filtering.\n */\nexport function doesShapeAcceptOperation(\n  shape: FragmentSelectorShape,\n  operation: Algebra.Operation,\n  options?: FragmentSelectorShapeTestFlags,\n): boolean {\n  return doesShapeAcceptOperationRecurseShape(shape, shape, operation, options);\n}\n\nfunction doesShapeAcceptOperationRecurseShape(\n  shapeTop: FragmentSelectorShape,\n  shapeActive: FragmentSelectorShape,\n  operation: Algebra.Operation,\n  options?: FragmentSelectorShapeTestFlags,\n): boolean {\n  // Recurse into the shape\n  if (shapeActive.type === 'conjunction') {\n    return shapeActive.children\n      .every(child => doesShapeAcceptOperationRecurseShape(shapeTop, child, operation, options));\n  }\n  if (shapeActive.type === 'disjunction') {\n    return shapeActive.children\n      .some(child => doesShapeAcceptOperationRecurseShape(shapeTop, child, operation, options));\n  }\n  if (shapeActive.type === 'arity') {\n    return doesShapeAcceptOperationRecurseShape(shapeTop, shapeActive.child, operation, options);\n  }\n\n  // Validate options\n  if ((options?.joinBindings && !shapeActive.joinBindings) ??\n    (options?.filterBindings && !shapeActive.filterBindings)) {\n    return false;\n  }\n\n  // Check if the shape's operation matches with the given operation\n  const shapeOperation = shapeActive.operation;\n  switch (shapeOperation.operationType) {\n    case 'type': {\n      if (!doesShapeAcceptOperationRecurseOperation(shapeTop, shapeActive, operation, options)) {\n        return false;\n      }\n      return shapeOperation.type === operation.type;\n    }\n    case 'pattern': {\n      if (!doesShapeAcceptOperationRecurseOperation(shapeTop, shapeActive, operation, options)) {\n        return false;\n      }\n      return shapeOperation.pattern.type === operation.type;\n    }\n    case 'wildcard': {\n      return true;\n    }\n  }\n}\n\nfunction doesShapeAcceptOperationRecurseOperation(\n  shapeTop: FragmentSelectorShape,\n  shapeActive: FragmentSelectorShape,\n  operation: Algebra.Operation,\n  options?: FragmentSelectorShapeTestFlags,\n): boolean {\n  // Recurse into the operation, and restart from the top-level shape\n  if (operation.input) {\n    const inputs: Algebra.Operation[] = Array.isArray(operation.input) ? operation.input : [ operation.input ];\n    if (!inputs.every(input => doesShapeAcceptOperationRecurseShape(shapeTop, shapeTop, input, options))) {\n      return false;\n    }\n  }\n  if (operation.patterns && !operation.patterns\n    .every((input: Algebra.Pattern) => doesShapeAcceptOperationRecurseShape(shapeTop, shapeTop, input, options))) {\n    return false;\n  }\n  return true;\n}\n\nexport type FragmentSelectorShapeTestFlags = {\n  joinBindings?: boolean;\n  filterBindings?: boolean;\n};\n"]}
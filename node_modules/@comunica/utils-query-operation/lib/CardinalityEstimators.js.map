{"version":3,"file":"CardinalityEstimators.js","sourceRoot":"","sources":["CardinalityEstimators.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IDataset, QueryResultCardinality } from '@comunica/types';\nimport { DataFactory } from 'rdf-data-factory';\nimport { Algebra, Factory, Util } from 'sparqlalgebrajs';\n\n// These are only used internally for estimates\nconst DF = new DataFactory();\nconst AF = new Factory(DF);\n\n/**\n * Estimate the cardinality of the provided operation using the specified dataset metadata.\n * This is the primary function that should be called to perform cardinality estimation.\n */\nexport function estimateCardinality(\n  operation: Algebra.Operation,\n  dataset: IDataset,\n): QueryResultCardinality {\n  const estimate = dataset.getCardinality(operation);\n\n  if (estimate) {\n    return estimate;\n  }\n\n  switch (operation.type) {\n    case Algebra.types.ASK:\n      return { type: 'exact', value: 1, dataset: dataset.uri };\n    case Algebra.types.LOAD:\n    case Algebra.types.DELETE_INSERT:\n    case Algebra.types.ADD:\n    case Algebra.types.COMPOSITE_UPDATE:\n    case Algebra.types.CLEAR:\n    case Algebra.types.NOP:\n    case Algebra.types.DROP:\n    case Algebra.types.CREATE:\n    case Algebra.types.MOVE:\n    case Algebra.types.COPY:\n      return { type: 'exact', value: 0, dataset: dataset.uri };\n    case Algebra.types.PROJECT:\n    case Algebra.types.FILTER:\n    case Algebra.types.ORDER_BY:\n    case Algebra.types.GROUP:\n    case Algebra.types.CONSTRUCT:\n    case Algebra.types.DISTINCT:\n    case Algebra.types.REDUCED:\n    case Algebra.types.EXTEND:\n    case Algebra.types.FROM:\n    case Algebra.types.GRAPH:\n      return estimateCardinality(operation.input, dataset);\n    case Algebra.types.ZERO_OR_ONE_PATH:\n    case Algebra.types.ZERO_OR_MORE_PATH:\n    case Algebra.types.ONE_OR_MORE_PATH:\n    case Algebra.types.INV:\n      return estimateCardinality(operation.path, dataset);\n    case Algebra.types.PATH:\n      return estimateCardinality(operation.predicate, dataset);\n    case Algebra.types.NPS:\n      return estimateNpsCardinality(operation, dataset);\n    case Algebra.types.LINK:\n      return estimateCardinality(AF.createPattern(DF.variable('s'), operation.iri, DF.variable('o')), dataset);\n    case Algebra.types.UNION:\n    case Algebra.types.SEQ:\n    case Algebra.types.ALT:\n      return estimateUnionCardinality(operation.input, dataset);\n    case Algebra.types.BGP:\n      return estimateJoinCardinality(operation.patterns, dataset);\n    case Algebra.types.JOIN:\n    case Algebra.types.LEFT_JOIN:\n      return estimateJoinCardinality(operation.input, dataset);\n    case Algebra.types.SLICE:\n      return estimateSliceCardinality(operation, dataset);\n    case Algebra.types.MINUS:\n      return estimateMinusCardinality(operation, dataset);\n    case Algebra.types.VALUES:\n      return { type: 'exact', value: operation.bindings.length, dataset: dataset.uri };\n    case Algebra.types.SERVICE:\n    case Algebra.types.DESCRIBE:\n    case Algebra.types.EXPRESSION:\n    case Algebra.types.PATTERN:\n      return { type: 'estimate', value: Number.POSITIVE_INFINITY, dataset: dataset.uri };\n  }\n}\n\n/**\n * Estimate the cardinality of a minus, by taking into account the input cardinalities.\n */\nexport function estimateMinusCardinality(\n  minus: Algebra.Minus,\n  dataset: IDataset,\n): QueryResultCardinality {\n  const estimateFirst = estimateCardinality(minus.input[0], dataset);\n  const estimateSecond = estimateCardinality(minus.input[1], dataset);\n  return {\n    type: 'estimate',\n    value: Math.max(estimateFirst.value - estimateSecond.value, 0),\n    dataset: dataset.uri,\n  };\n}\n\n/**\n * Estimate the cardinality of a slice operation, taking into account the input cardinality and the slice range.\n */\nexport function estimateSliceCardinality(\n  slice: Algebra.Slice,\n  dataset: IDataset,\n): QueryResultCardinality {\n  const estimate = estimateCardinality(slice.input, dataset);\n  if (estimate.value > 0) {\n    estimate.value = Math.max(estimate.value - slice.start, 0);\n    if (slice.length !== undefined) {\n      estimate.value = Math.min(estimate.value, slice.length);\n    }\n  }\n  return estimate;\n}\n\n/**\n * Estimate the cardinality of a union, using a sum of the individual input cardinalities.\n */\nexport function estimateUnionCardinality(\n  input: Algebra.Operation[],\n  dataset: IDataset,\n): QueryResultCardinality {\n  const estimate: QueryResultCardinality = { type: 'exact', value: 0, dataset: dataset.uri };\n  for (const operation of input) {\n    const cardinality = estimateCardinality(operation, dataset);\n    if (cardinality.type === 'estimate' && estimate.type === 'exact') {\n      estimate.type = cardinality.type;\n    }\n    if (cardinality.value > 0) {\n      estimate.value += cardinality.value;\n    }\n  }\n  return estimate;\n}\n\n/**\n * Estimate the cardinality of a join. This estimation is done by:\n *  1. Grouping operations together based on variables.\n *  2. Selecting the minimum op cardinality in each group as the cardinality of that group.\n *  3. Multiplying cardinalities of these (detached) groups.\n *\n * This should provide a good balance between selective groups of operations,\n * as well as cartesian joins between groups that do not overlap.\n */\nexport function estimateJoinCardinality(\n  operations: Algebra.Operation[],\n  dataset: IDataset,\n): QueryResultCardinality {\n  const operationGroups: { ops: Algebra.Operation[]; vars: Set<string> }[] = [];\n  for (const operation of operations) {\n    const vars = Util.inScopeVariables(operation).map(v => v.value);\n    const group = operationGroups.find(g => vars.some(v => g.vars.has(v)));\n    if (group) {\n      group.ops.push(operation);\n      for (const v of vars) {\n        group.vars.add(v);\n      }\n    } else {\n      operationGroups.push({ ops: [ operation ], vars: new Set(vars) });\n    }\n  }\n  const cardinality: QueryResultCardinality = {\n    type: 'estimate',\n    value: operationGroups\n      .map(g => Math.min(...g.ops.map(o => estimateCardinality(o, dataset).value)))\n      .reduce((acc, cur) => acc * cur, 1),\n    dataset: dataset.uri,\n  };\n  return cardinality;\n}\n\n/**\n * Estimate the cardinality of a negated property set, by subtracting the non-inversed\n * estimate from the total number of triples.\n */\nexport function estimateNpsCardinality(\n  nps: Algebra.Nps,\n  dataset: IDataset,\n): QueryResultCardinality {\n  const seq = AF.createSeq([ ...nps.iris ].reverse().map(iri => AF.createLink(iri)));\n  const seqCardinality = estimateCardinality(seq, dataset);\n  const pattern = AF.createPattern(DF.variable('s'), DF.variable('p'), DF.variable('o'));\n  const patternCardinality = estimateCardinality(pattern, dataset);\n  return {\n    type: 'estimate',\n    value: Math.max(0, patternCardinality.value - seqCardinality.value),\n    dataset: dataset.uri,\n  };\n}\n"]}
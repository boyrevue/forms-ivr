"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.estimateNpsCardinality = exports.estimateJoinCardinality = exports.estimateUnionCardinality = exports.estimateSliceCardinality = exports.estimateMinusCardinality = exports.estimateCardinality = void 0;
const rdf_data_factory_1 = require("rdf-data-factory");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
// These are only used internally for estimates
const DF = new rdf_data_factory_1.DataFactory();
const AF = new sparqlalgebrajs_1.Factory(DF);
/**
 * Estimate the cardinality of the provided operation using the specified dataset metadata.
 * This is the primary function that should be called to perform cardinality estimation.
 */
function estimateCardinality(operation, dataset) {
    const estimate = dataset.getCardinality(operation);
    if (estimate) {
        return estimate;
    }
    switch (operation.type) {
        case sparqlalgebrajs_1.Algebra.types.ASK:
            return { type: 'exact', value: 1, dataset: dataset.uri };
        case sparqlalgebrajs_1.Algebra.types.LOAD:
        case sparqlalgebrajs_1.Algebra.types.DELETE_INSERT:
        case sparqlalgebrajs_1.Algebra.types.ADD:
        case sparqlalgebrajs_1.Algebra.types.COMPOSITE_UPDATE:
        case sparqlalgebrajs_1.Algebra.types.CLEAR:
        case sparqlalgebrajs_1.Algebra.types.NOP:
        case sparqlalgebrajs_1.Algebra.types.DROP:
        case sparqlalgebrajs_1.Algebra.types.CREATE:
        case sparqlalgebrajs_1.Algebra.types.MOVE:
        case sparqlalgebrajs_1.Algebra.types.COPY:
            return { type: 'exact', value: 0, dataset: dataset.uri };
        case sparqlalgebrajs_1.Algebra.types.PROJECT:
        case sparqlalgebrajs_1.Algebra.types.FILTER:
        case sparqlalgebrajs_1.Algebra.types.ORDER_BY:
        case sparqlalgebrajs_1.Algebra.types.GROUP:
        case sparqlalgebrajs_1.Algebra.types.CONSTRUCT:
        case sparqlalgebrajs_1.Algebra.types.DISTINCT:
        case sparqlalgebrajs_1.Algebra.types.REDUCED:
        case sparqlalgebrajs_1.Algebra.types.EXTEND:
        case sparqlalgebrajs_1.Algebra.types.FROM:
        case sparqlalgebrajs_1.Algebra.types.GRAPH:
            return estimateCardinality(operation.input, dataset);
        case sparqlalgebrajs_1.Algebra.types.ZERO_OR_ONE_PATH:
        case sparqlalgebrajs_1.Algebra.types.ZERO_OR_MORE_PATH:
        case sparqlalgebrajs_1.Algebra.types.ONE_OR_MORE_PATH:
        case sparqlalgebrajs_1.Algebra.types.INV:
            return estimateCardinality(operation.path, dataset);
        case sparqlalgebrajs_1.Algebra.types.PATH:
            return estimateCardinality(operation.predicate, dataset);
        case sparqlalgebrajs_1.Algebra.types.NPS:
            return estimateNpsCardinality(operation, dataset);
        case sparqlalgebrajs_1.Algebra.types.LINK:
            return estimateCardinality(AF.createPattern(DF.variable('s'), operation.iri, DF.variable('o')), dataset);
        case sparqlalgebrajs_1.Algebra.types.UNION:
        case sparqlalgebrajs_1.Algebra.types.SEQ:
        case sparqlalgebrajs_1.Algebra.types.ALT:
            return estimateUnionCardinality(operation.input, dataset);
        case sparqlalgebrajs_1.Algebra.types.BGP:
            return estimateJoinCardinality(operation.patterns, dataset);
        case sparqlalgebrajs_1.Algebra.types.JOIN:
        case sparqlalgebrajs_1.Algebra.types.LEFT_JOIN:
            return estimateJoinCardinality(operation.input, dataset);
        case sparqlalgebrajs_1.Algebra.types.SLICE:
            return estimateSliceCardinality(operation, dataset);
        case sparqlalgebrajs_1.Algebra.types.MINUS:
            return estimateMinusCardinality(operation, dataset);
        case sparqlalgebrajs_1.Algebra.types.VALUES:
            return { type: 'exact', value: operation.bindings.length, dataset: dataset.uri };
        case sparqlalgebrajs_1.Algebra.types.SERVICE:
        case sparqlalgebrajs_1.Algebra.types.DESCRIBE:
        case sparqlalgebrajs_1.Algebra.types.EXPRESSION:
        case sparqlalgebrajs_1.Algebra.types.PATTERN:
            return { type: 'estimate', value: Number.POSITIVE_INFINITY, dataset: dataset.uri };
    }
}
exports.estimateCardinality = estimateCardinality;
/**
 * Estimate the cardinality of a minus, by taking into account the input cardinalities.
 */
function estimateMinusCardinality(minus, dataset) {
    const estimateFirst = estimateCardinality(minus.input[0], dataset);
    const estimateSecond = estimateCardinality(minus.input[1], dataset);
    return {
        type: 'estimate',
        value: Math.max(estimateFirst.value - estimateSecond.value, 0),
        dataset: dataset.uri,
    };
}
exports.estimateMinusCardinality = estimateMinusCardinality;
/**
 * Estimate the cardinality of a slice operation, taking into account the input cardinality and the slice range.
 */
function estimateSliceCardinality(slice, dataset) {
    const estimate = estimateCardinality(slice.input, dataset);
    if (estimate.value > 0) {
        estimate.value = Math.max(estimate.value - slice.start, 0);
        if (slice.length !== undefined) {
            estimate.value = Math.min(estimate.value, slice.length);
        }
    }
    return estimate;
}
exports.estimateSliceCardinality = estimateSliceCardinality;
/**
 * Estimate the cardinality of a union, using a sum of the individual input cardinalities.
 */
function estimateUnionCardinality(input, dataset) {
    const estimate = { type: 'exact', value: 0, dataset: dataset.uri };
    for (const operation of input) {
        const cardinality = estimateCardinality(operation, dataset);
        if (cardinality.type === 'estimate' && estimate.type === 'exact') {
            estimate.type = cardinality.type;
        }
        if (cardinality.value > 0) {
            estimate.value += cardinality.value;
        }
    }
    return estimate;
}
exports.estimateUnionCardinality = estimateUnionCardinality;
/**
 * Estimate the cardinality of a join. This estimation is done by:
 *  1. Grouping operations together based on variables.
 *  2. Selecting the minimum op cardinality in each group as the cardinality of that group.
 *  3. Multiplying cardinalities of these (detached) groups.
 *
 * This should provide a good balance between selective groups of operations,
 * as well as cartesian joins between groups that do not overlap.
 */
function estimateJoinCardinality(operations, dataset) {
    const operationGroups = [];
    for (const operation of operations) {
        const vars = sparqlalgebrajs_1.Util.inScopeVariables(operation).map(v => v.value);
        const group = operationGroups.find(g => vars.some(v => g.vars.has(v)));
        if (group) {
            group.ops.push(operation);
            for (const v of vars) {
                group.vars.add(v);
            }
        }
        else {
            operationGroups.push({ ops: [operation], vars: new Set(vars) });
        }
    }
    const cardinality = {
        type: 'estimate',
        value: operationGroups
            .map(g => Math.min(...g.ops.map(o => estimateCardinality(o, dataset).value)))
            .reduce((acc, cur) => acc * cur, 1),
        dataset: dataset.uri,
    };
    return cardinality;
}
exports.estimateJoinCardinality = estimateJoinCardinality;
/**
 * Estimate the cardinality of a negated property set, by subtracting the non-inversed
 * estimate from the total number of triples.
 */
function estimateNpsCardinality(nps, dataset) {
    const seq = AF.createSeq([...nps.iris].reverse().map(iri => AF.createLink(iri)));
    const seqCardinality = estimateCardinality(seq, dataset);
    const pattern = AF.createPattern(DF.variable('s'), DF.variable('p'), DF.variable('o'));
    const patternCardinality = estimateCardinality(pattern, dataset);
    return {
        type: 'estimate',
        value: Math.max(0, patternCardinality.value - seqCardinality.value),
        dataset: dataset.uri,
    };
}
exports.estimateNpsCardinality = estimateNpsCardinality;
//# sourceMappingURL=CardinalityEstimators.js.map
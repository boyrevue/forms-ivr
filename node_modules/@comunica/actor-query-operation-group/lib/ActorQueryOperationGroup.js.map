{"version":3,"file":"ActorQueryOperationGroup.js","sourceRoot":"","sources":["ActorQueryOperationGroup.ts"],"names":[],"mappings":"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","sourcesContent":["import type { MediatorBindingsAggregatorFactory } from '@comunica/bus-bindings-aggregator-factory';\nimport type { MediatorMergeBindingsContext } from '@comunica/bus-merge-bindings-context';\nimport type { IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport { ActorQueryOperationTypedMediated } from '@comunica/bus-query-operation';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type { IActorTest, TestResult } from '@comunica/core';\nimport { passTestVoid } from '@comunica/core';\nimport type {\n  BindingsStream,\n  ComunicaDataFactory,\n  IActionContext,\n  IQueryOperationResult,\n  MetadataVariable,\n} from '@comunica/types';\nimport { BindingsFactory } from '@comunica/utils-bindings-factory';\nimport { getSafeBindings } from '@comunica/utils-query-operation';\nimport { ArrayIterator, TransformIterator } from 'asynciterator';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport { GroupsState } from './GroupsState';\n\n/**\n * A comunica Group Query Operation Actor.\n */\nexport class ActorQueryOperationGroup extends ActorQueryOperationTypedMediated<Algebra.Group> {\n  public readonly mediatorMergeBindingsContext: MediatorMergeBindingsContext;\n  private readonly mediatorBindingsAggregatorFactory: MediatorBindingsAggregatorFactory;\n\n  public constructor(args: IActorQueryOperationGroupArgs) {\n    super(args, 'group');\n    this.mediatorBindingsAggregatorFactory = args.mediatorBindingsAggregatorFactory;\n  }\n\n  public async testOperation(): Promise<TestResult<IActorTest>> {\n    return passTestVoid();\n  }\n\n  public async runOperation(operation: Algebra.Group, context: IActionContext):\n  Promise<IQueryOperationResult> {\n    const dataFactory: ComunicaDataFactory = context.getSafe(KeysInitQuery.dataFactory);\n    const bindingsFactory = await BindingsFactory.create(this.mediatorMergeBindingsContext, context, dataFactory);\n\n    // Get result stream for the input query\n    const { input, aggregates } = operation;\n    const outputRaw = await this.mediatorQueryOperation.mediate({ operation: input, context });\n    const output = getSafeBindings(outputRaw);\n\n    // The variables in scope are the variables on which we group, i.e. pattern.variables.\n    // For 'GROUP BY ?x, ?z', this is [?x, ?z], for 'GROUP by expr(?x) as ?e' this is [?e].\n    // But also in scope are the variables defined by the aggregations, since GROUP has to handle this.\n    const variables: MetadataVariable[] = [\n      ...operation.variables,\n      ...aggregates.map(agg => agg.variable),\n    ].map(variable => ({ variable, canBeUndef: false }));\n\n    const variablesInner = (await output.metadata()).variables.map(v => v.variable);\n\n    // Wrap a new promise inside an iterator that completes when the stream has ended or when an error occurs\n    const bindingsStream = new TransformIterator(() => new Promise<BindingsStream>((resolve, reject) => {\n      const groups = new GroupsState(\n        operation,\n        this.mediatorBindingsAggregatorFactory,\n        context,\n        bindingsFactory,\n        variablesInner,\n      );\n\n      // Phase 2: Collect aggregator results\n      // We can only return when the binding stream ends, when that happens\n      // we return the identified groups. Which are nothing more than Bindings\n      // of the grouping variables merged with the aggregate variables\n      // eslint-disable-next-line ts/no-misused-promises\n      output.bindingsStream.on('end', async() => {\n        try {\n          const bindingsStreamInner = new ArrayIterator(await groups.collectResults(), { autoStart: false });\n          resolve(bindingsStreamInner);\n        } catch (error: unknown) {\n          reject(error);\n        }\n      });\n\n      // Make sure to propagate any errors in the binding stream\n      output.bindingsStream.on('error', reject);\n\n      // Phase 1: Consume the stream, identify the groups and populate the aggregators.\n      // We need to bind this after the 'error' and 'end' listeners to avoid the\n      // stream having ended before those listeners are bound.\n      output.bindingsStream.on('data', (bindings) => {\n        groups.consumeBindings(bindings).catch(reject);\n      });\n    }), { autoStart: false });\n\n    return {\n      type: 'bindings',\n      bindingsStream,\n      metadata: async() => ({ ...await output.metadata(), variables }),\n    };\n  }\n}\n\nexport interface IActorQueryOperationGroupArgs extends IActorQueryOperationTypedMediatedArgs {\n  /**\n   * A mediator for creating binding context merge handlers\n   */\n  mediatorMergeBindingsContext: MediatorMergeBindingsContext;\n  mediatorBindingsAggregatorFactory: MediatorBindingsAggregatorFactory;\n}\n"]}
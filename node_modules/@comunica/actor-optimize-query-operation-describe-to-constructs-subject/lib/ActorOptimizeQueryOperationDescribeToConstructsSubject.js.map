{"version":3,"file":"ActorOptimizeQueryOperationDescribeToConstructsSubject.js","sourceRoot":"","sources":["ActorOptimizeQueryOperationDescribeToConstructsSubject.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  IActionOptimizeQueryOperation,\n  IActorOptimizeQueryOperationOutput,\n  IActorOptimizeQueryOperationArgs,\n} from '@comunica/bus-optimize-query-operation';\nimport { ActorOptimizeQueryOperation } from '@comunica/bus-optimize-query-operation';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type { IActorTest, TestResult } from '@comunica/core';\nimport { failTest, passTest } from '@comunica/core';\nimport type { ComunicaDataFactory } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { Algebra, Factory } from 'sparqlalgebrajs';\n\n/**\n * A comunica Describe To Constructs Subject Optimize Query Operation Actor.\n */\nexport class ActorOptimizeQueryOperationDescribeToConstructsSubject extends ActorOptimizeQueryOperation {\n  public constructor(args: IActorOptimizeQueryOperationArgs) {\n    super(args);\n  }\n\n  public async test(action: IActionOptimizeQueryOperation): Promise<TestResult<IActorTest>> {\n    if (action.operation.type !== Algebra.types.DESCRIBE) {\n      return failTest(`Actor ${this.name} only supports describe operations, but got ${action.operation.type}`);\n    }\n    return passTest(true);\n  }\n\n  public async run(action: IActionOptimizeQueryOperation): Promise<IActorOptimizeQueryOperationOutput> {\n    const dataFactory: ComunicaDataFactory = action.context.getSafe(KeysInitQuery.dataFactory);\n    const algebraFactory = new Factory(dataFactory);\n\n    const operationOriginal: Algebra.Describe = <Algebra.Describe> action.operation;\n\n    // Create separate construct queries for all non-variable terms\n    const operations: Algebra.Construct[] = operationOriginal.terms\n      .filter(term => term.termType !== 'Variable')\n      .map((term: RDF.Term) => {\n        // Transform each term to a separate construct operation with S ?p ?o patterns (BGP) for all terms\n        const patterns: RDF.BaseQuad[] = [\n          dataFactory.quad(\n            <RDF.Quad_Subject> term,\n            dataFactory.variable('__predicate'),\n            dataFactory.variable('__object'),\n          ),\n        ];\n\n        // eslint-disable-next-line unicorn/no-array-for-each\n        patterns.forEach((templatePattern: any) => templatePattern.type = 'pattern');\n        const templateOperation: Algebra.Operation = {\n          type: Algebra.types.BGP,\n          patterns: <Algebra.Pattern[]> patterns,\n        };\n\n        // Create a construct query\n        return <Algebra.Construct> {\n          input: templateOperation,\n          template: <Algebra.Pattern[]> patterns,\n          type: 'construct',\n        };\n      });\n\n    // If we have variables in the term list,\n    // create one separate construct operation to determine these variables using the input pattern.\n    if (operations.length !== operationOriginal.terms.length) {\n      let variablePatterns: Algebra.Pattern[] = [];\n      operationOriginal.terms\n        .filter(term => term.termType === 'Variable')\n        // eslint-disable-next-line unicorn/no-array-for-each\n        .forEach((term: RDF.Term, i: number) => {\n          // Transform each term to an S ?p ?o pattern in a non-conflicting way\n          const patterns: RDF.BaseQuad[] = [\n            dataFactory.quad(\n              <RDF.Quad_Subject> term,\n              dataFactory.variable(`__predicate${i}`),\n              dataFactory.variable(`__object${i}`),\n            ),\n          ];\n\n          // eslint-disable-next-line unicorn/no-array-for-each\n          patterns.forEach((templatePattern: any) => templatePattern.type = 'pattern');\n          variablePatterns = [ ...variablePatterns, ...<Algebra.Pattern[]> patterns ];\n        });\n\n      // Add a single construct for the variables\n      // This requires a join between the input pattern and our variable patterns that form a simple BGP\n      operations.push({\n        input: {\n          type: Algebra.types.JOIN,\n          input: [\n            operationOriginal.input,\n            { type: Algebra.types.BGP, patterns: variablePatterns },\n          ],\n        },\n        template: variablePatterns,\n        type: Algebra.types.CONSTRUCT,\n      });\n    }\n\n    // Union the construct operations\n    const operation = algebraFactory.createUnion(operations, false);\n\n    return { operation, context: action.context };\n  }\n}\n"]}
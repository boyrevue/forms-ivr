{"version":3,"file":"QuerySourceSparql.js","sourceRoot":"","sources":["QuerySourceSparql.ts"],"names":[],"mappings":"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","sourcesContent":["import type { MediatorHttp } from '@comunica/bus-http';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport { Actor } from '@comunica/core';\nimport type {\n  Bindings,\n  BindingsStream,\n  ComunicaDataFactory,\n  FragmentSelectorShape,\n  IActionContext,\n  IDataset,\n  IQueryBindingsOptions,\n  IQuerySource,\n  MetadataBindings,\n  MetadataVariable,\n  QueryResultCardinality,\n} from '@comunica/types';\nimport type { BindingsFactory } from '@comunica/utils-bindings-factory';\nimport { MetadataValidationState } from '@comunica/utils-metadata';\nimport { estimateCardinality } from '@comunica/utils-query-operation';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { TransformIterator, wrap } from 'asynciterator';\nimport { SparqlEndpointFetcher } from 'fetch-sparql-endpoint';\nimport { LRUCache } from 'lru-cache';\nimport { uniqTerms } from 'rdf-terms';\nimport type { Factory } from 'sparqlalgebrajs';\nimport { toSparql, Algebra, Util } from 'sparqlalgebrajs';\nimport type { BindMethod } from './ActorQuerySourceIdentifyHypermediaSparql';\n\nexport class QuerySourceSparql implements IQuerySource {\n  protected static readonly SELECTOR_SHAPE: FragmentSelectorShape = {\n    type: 'disjunction',\n    children: [\n      {\n        type: 'operation',\n        operation: { operationType: 'wildcard' },\n        joinBindings: true,\n      },\n    ],\n  };\n\n  public readonly referenceValue: string;\n  private readonly url: string;\n  private readonly context: IActionContext;\n  private readonly mediatorHttp: MediatorHttp;\n  private readonly bindMethod: BindMethod;\n  private readonly countTimeout: number;\n  private readonly cardinalityCountQueries: boolean;\n  private readonly cardinalityEstimateConstruction: boolean;\n  private readonly defaultGraph?: string;\n  private readonly unionDefaultGraph: boolean;\n  private readonly datasets?: IDataset[];\n  private readonly dataFactory: ComunicaDataFactory;\n  private readonly algebraFactory: Factory;\n  private readonly bindingsFactory: BindingsFactory;\n\n  private readonly endpointFetcher: SparqlEndpointFetcher;\n  private readonly cache: LRUCache<string, QueryResultCardinality> | undefined;\n\n  private lastSourceContext: IActionContext | undefined;\n\n  public constructor(\n    url: string,\n    context: IActionContext,\n    mediatorHttp: MediatorHttp,\n    bindMethod: BindMethod,\n    dataFactory: ComunicaDataFactory,\n    algebraFactory: Factory,\n    bindingsFactory: BindingsFactory,\n    forceHttpGet: boolean,\n    cacheSize: number,\n    countTimeout: number,\n    cardinalityCountQueries: boolean,\n    cardinalityEstimateConstruction: boolean,\n    defaultGraph?: string,\n    unionDefaultGraph?: boolean,\n    datasets?: IDataset[],\n  ) {\n    this.referenceValue = url;\n    this.url = url;\n    this.context = context;\n    this.mediatorHttp = mediatorHttp;\n    this.bindMethod = bindMethod;\n    this.dataFactory = dataFactory;\n    this.algebraFactory = algebraFactory;\n    this.bindingsFactory = bindingsFactory;\n    this.endpointFetcher = new SparqlEndpointFetcher({\n      method: forceHttpGet ? 'GET' : 'POST',\n      fetch: (input: Request | string, init?: RequestInit) => this.mediatorHttp.mediate(\n        { input, init, context: this.lastSourceContext! },\n      ),\n      prefixVariableQuestionMark: true,\n      dataFactory,\n    });\n    this.cache = cacheSize > 0 ?\n      new LRUCache<string, QueryResultCardinality>({ max: cacheSize }) :\n      undefined;\n    this.countTimeout = countTimeout;\n    this.cardinalityCountQueries = cardinalityCountQueries;\n    this.cardinalityEstimateConstruction = cardinalityEstimateConstruction;\n    this.defaultGraph = defaultGraph;\n    this.unionDefaultGraph = unionDefaultGraph ?? false;\n    this.datasets = datasets;\n  }\n\n  public async getSelectorShape(): Promise<FragmentSelectorShape> {\n    return QuerySourceSparql.SELECTOR_SHAPE;\n  }\n\n  public queryBindings(\n    operationIn: Algebra.Operation,\n    context: IActionContext,\n    options?: IQueryBindingsOptions,\n  ): BindingsStream {\n    // If bindings are passed, modify the operations\n    let operationPromise: Promise<Algebra.Operation>;\n    if (options?.joinBindings) {\n      operationPromise = QuerySourceSparql.addBindingsToOperation(\n        this.algebraFactory,\n        this.bindMethod,\n        operationIn,\n        options.joinBindings,\n      );\n    } else {\n      operationPromise = Promise.resolve(operationIn);\n    }\n\n    const bindings: BindingsStream = new TransformIterator(async() => {\n      // Prepare queries\n      const operation = await operationPromise;\n      const variables: RDF.Variable[] = Util.inScopeVariables(operation);\n      const queryString = context.get<string>(KeysInitQuery.queryString);\n      const queryFormat: RDF.QueryFormat = context.getSafe(KeysInitQuery.queryFormat);\n      const selectQuery: string = !options?.joinBindings && queryString && queryFormat.language === 'sparql' ?\n        queryString :\n        QuerySourceSparql.operationToSelectQuery(this.algebraFactory, operation, variables);\n      const undefVariables = QuerySourceSparql.getOperationUndefs(operation);\n\n      return this.queryBindingsRemote(this.url, selectQuery, variables, context, undefVariables);\n    }, { autoStart: false });\n    this.attachMetadata(bindings, context, operationPromise);\n\n    return bindings;\n  }\n\n  public queryQuads(operation: Algebra.Operation, context: IActionContext): AsyncIterator<RDF.Quad> {\n    this.lastSourceContext = this.context.merge(context);\n    const rawStream = this.endpointFetcher.fetchTriples(\n      this.url,\n      context.get(KeysInitQuery.queryString) ?? QuerySourceSparql.operationToQuery(operation),\n    );\n    this.lastSourceContext = undefined;\n    const quads = wrap<any>(rawStream, { autoStart: false, maxBufferSize: Number.POSITIVE_INFINITY });\n    this.attachMetadata(quads, context, Promise.resolve(operation.input));\n    return quads;\n  }\n\n  public queryBoolean(operation: Algebra.Ask, context: IActionContext): Promise<boolean> {\n    this.lastSourceContext = this.context.merge(context);\n    const promise = this.endpointFetcher.fetchAsk(\n      this.url,\n      context.get(KeysInitQuery.queryString) ?? QuerySourceSparql.operationToQuery(operation),\n    );\n    this.lastSourceContext = undefined;\n    return promise;\n  }\n\n  public queryVoid(operation: Algebra.Update, context: IActionContext): Promise<void> {\n    this.lastSourceContext = this.context.merge(context);\n    const promise = this.endpointFetcher.fetchUpdate(\n      this.url,\n      context.get(KeysInitQuery.queryString) ?? QuerySourceSparql.operationToQuery(operation),\n    );\n    this.lastSourceContext = undefined;\n    return promise;\n  }\n\n  protected attachMetadata(\n    target: AsyncIterator<any>,\n    context: IActionContext,\n    operationPromise: Promise<Algebra.Operation>,\n  ): void {\n    // Emit metadata containing the estimated count\n    let variablesCount: MetadataVariable[] = [];\n    // eslint-disable-next-line no-async-promise-executor,ts/no-misused-promises\n    new Promise<QueryResultCardinality>(async(resolve, reject) => {\n      try {\n        const operation = await operationPromise;\n        const variablesScoped = Util.inScopeVariables(operation);\n        const countQuery = this.operationToNormalizedCountQuery(operation);\n        const undefVariables = QuerySourceSparql.getOperationUndefs(operation);\n        variablesCount = variablesScoped.map(variable => ({\n          variable,\n          canBeUndef: undefVariables.some(undefVariable => undefVariable.equals(variable)),\n        }));\n\n        const cachedCardinality = this.cache?.get(countQuery);\n        if (cachedCardinality) {\n          return resolve(cachedCardinality);\n        }\n\n        // Attempt to estimate locally prior to sending a COUNT request, as this should be much faster.\n        // The estimates may be off by varying amounts, so this is set behind a configuration flag.\n        if (this.cardinalityEstimateConstruction) {\n          const localEstimate = await this.estimateOperationCardinality(operation);\n          if (Number.isFinite(localEstimate.value)) {\n            this.cache?.set(countQuery, localEstimate);\n            return resolve(localEstimate);\n          }\n        }\n\n        // Don't send count queries if disabled.\n        if (!this.cardinalityCountQueries) {\n          return resolve({ type: 'estimate', value: Number.POSITIVE_INFINITY, dataset: this.url });\n        }\n\n        const timeoutHandler = setTimeout(() => resolve({\n          type: 'estimate',\n          value: Number.POSITIVE_INFINITY,\n          dataset: this.url,\n        }), this.countTimeout);\n        const varCount = this.dataFactory.variable('count');\n        const bindingsStream: BindingsStream = await this\n          .queryBindingsRemote(this.url, countQuery, [ varCount ], context, []);\n        bindingsStream.on('data', (bindings: Bindings) => {\n          clearTimeout(timeoutHandler);\n          const count = bindings.get(varCount);\n          const cardinality: QueryResultCardinality = {\n            type: 'estimate',\n            value: Number.POSITIVE_INFINITY,\n            dataset: this.url,\n          };\n          if (count) {\n            const cardinalityValue: number = Number.parseInt(count.value, 10);\n            if (!Number.isNaN(cardinalityValue)) {\n              cardinality.type = 'exact';\n              cardinality.value = cardinalityValue;\n              this.cache?.set(countQuery, cardinality);\n            }\n          }\n          return resolve(cardinality);\n        });\n        bindingsStream.on('error', () => {\n          clearTimeout(timeoutHandler);\n          resolve({ type: 'estimate', value: Number.POSITIVE_INFINITY, dataset: this.url });\n        });\n        bindingsStream.on('end', () => {\n          clearTimeout(timeoutHandler);\n          resolve({ type: 'estimate', value: Number.POSITIVE_INFINITY, dataset: this.url });\n        });\n      } catch (error: unknown) {\n        return reject(error);\n      }\n    })\n      .then((cardinality) => {\n        target.setProperty('metadata', {\n          state: new MetadataValidationState(),\n          cardinality,\n          variables: variablesCount,\n        });\n      })\n      .catch(() => target.setProperty('metadata', {\n        state: new MetadataValidationState(),\n        cardinality: { type: 'estimate', value: Number.POSITIVE_INFINITY, dataset: this.url },\n        variables: variablesCount,\n      }));\n  }\n\n  /**\n   * Convert an algebra operation into a query string, and if the operation is a simple triple pattern,\n   * then also replace any variables with s, p, and o to increase the chance of cache hits.\n   * @param {Algebra.Operation} operation The operation to convert into a query string.\n   * @returns {string} Query string for a COUNT query over the operation.\n   */\n  public operationToNormalizedCountQuery(operation: Algebra.Operation): string {\n    const normalizedOperation = operation.type === Algebra.types.PATTERN ?\n      this.algebraFactory.createPattern(\n        operation.subject.termType === 'Variable' ? this.dataFactory.variable('s') : operation.subject,\n        operation.predicate.termType === 'Variable' ? this.dataFactory.variable('p') : operation.predicate,\n        operation.object.termType === 'Variable' ? this.dataFactory.variable('o') : operation.object,\n      ) :\n      operation;\n    const operationString = QuerySourceSparql.operationToCountQuery(\n      this.dataFactory,\n      this.algebraFactory,\n      normalizedOperation,\n    );\n    return operationString;\n  }\n\n  /**\n   * Performs local cardinality estimation for the specified SPARQL algebra operation, which should\n   * result in better estimation performance at the expense of accuracy.\n   * @param {Algebra.Operation} operation A query operation.\n   */\n  public async estimateOperationCardinality(operation: Algebra.Operation): Promise<QueryResultCardinality> {\n    const dataset: IDataset = {\n      getCardinality: (operation: Algebra.Operation): QueryResultCardinality | undefined => {\n        const queryString = this.operationToNormalizedCountQuery(operation);\n\n        const cachedCardinality = this.cache?.get(queryString);\n        if (cachedCardinality) {\n          return cachedCardinality;\n        }\n\n        if (this.datasets) {\n          const cardinalities = this.datasets\n            .filter(ds => this.unionDefaultGraph || (this.defaultGraph && ds.uri.endsWith(this.defaultGraph)))\n            .map(ds => estimateCardinality(operation, ds));\n\n          const cardinality: QueryResultCardinality = {\n            type: cardinalities.some(card => card.type === 'estimate') ? 'estimate' : 'exact',\n            value: cardinalities.length > 0 ? cardinalities.reduce((acc, card) => acc + card.value, 0) : 0,\n            dataset: this.url,\n          };\n\n          return cardinality;\n        }\n      },\n      source: this.url,\n      uri: this.url,\n    };\n\n    return estimateCardinality(operation, dataset);\n  }\n\n  /**\n   * Create an operation that includes the bindings from the given bindings stream.\n   * @param algebraFactory The algebra factory.\n   * @param bindMethod A method for adding bindings to an operation.\n   * @param operation The operation to bind to.\n   * @param addBindings The bindings to add.\n   * @param addBindings.bindings The bindings stream.\n   * @param addBindings.metadata The bindings metadata.\n   */\n  public static async addBindingsToOperation(\n    algebraFactory: Factory,\n    bindMethod: BindMethod,\n    operation: Algebra.Operation,\n    addBindings: { bindings: BindingsStream; metadata: MetadataBindings },\n  ): Promise<Algebra.Operation> {\n    const bindings = await addBindings.bindings.toArray();\n\n    switch (bindMethod) {\n      case 'values':\n        return algebraFactory.createJoin([\n          algebraFactory.createValues(\n            addBindings.metadata.variables.map(v => v.variable),\n            bindings.map(binding => Object.fromEntries([ ...binding ]\n              .map(([ key, value ]) => [ `?${key.value}`, <RDF.Literal | RDF.NamedNode> value ]))),\n          ),\n          operation,\n        ], false);\n      case 'union': { throw new Error('Not implemented yet: \"union\" case'); }\n      case 'filter': { throw new Error('Not implemented yet: \"filter\" case'); }\n    }\n  }\n\n  /**\n   * Convert an operation to a select query for this pattern.\n   * @param algebraFactory The algebra factory.\n   * @param {Algebra.Operation} operation A query operation.\n   * @param {RDF.Variable[]} variables The variables in scope for the operation.\n   * @return {string} A select query string.\n   */\n  public static operationToSelectQuery(\n    algebraFactory: Factory,\n    operation: Algebra.Operation,\n    variables: RDF.Variable[],\n  ): string {\n    return QuerySourceSparql.operationToQuery(algebraFactory.createProject(operation, variables));\n  }\n\n  /**\n   * Convert an operation to a count query for the number of matching triples for this pattern.\n   * @param dataFactory The data factory.\n   * @param algebraFactory The algebra factory.\n   * @param {Algebra.Operation} operation A query operation.\n   * @return {string} A count query string.\n   */\n  public static operationToCountQuery(\n    dataFactory: ComunicaDataFactory,\n    algebraFactory: Factory,\n    operation: Algebra.Operation,\n  ): string {\n    return QuerySourceSparql.operationToQuery(algebraFactory.createProject(\n      algebraFactory.createExtend(\n        algebraFactory.createGroup(\n          operation,\n          [],\n          [ algebraFactory.createBoundAggregate(\n            dataFactory.variable('var0'),\n            'count',\n            algebraFactory.createWildcardExpression(),\n            false,\n          ) ],\n        ),\n        dataFactory.variable('count'),\n        algebraFactory.createTermExpression(dataFactory.variable('var0')),\n      ),\n      [ dataFactory.variable('count') ],\n    ));\n  }\n\n  /**\n   * Convert an operation to a query for this pattern.\n   * @param {Algebra.Operation} operation A query operation.\n   * @return {string} A query string.\n   */\n  public static operationToQuery(operation: Algebra.Operation): string {\n    return toSparql(operation, { sparqlStar: true });\n  }\n\n  /**\n   * Check if the given operation may produce undefined values.\n   * @param operation\n   */\n  public static getOperationUndefs(operation: Algebra.Operation): RDF.Variable[] {\n    const variables: RDF.Variable[] = [];\n    Util.recurseOperation(operation, {\n      leftjoin(subOperation): boolean {\n        const left = Util.inScopeVariables(subOperation.input[0]);\n        const right = Util.inScopeVariables(subOperation.input[1]);\n        for (const varRight of right) {\n          if (!left.some(varLeft => varLeft.equals(varRight))) {\n            variables.push(varRight);\n          }\n        }\n        return false;\n      },\n      values(values: Algebra.Values): boolean {\n        for (const variable of values.variables) {\n          if (values.bindings.some(bindings => !(`?${variable.value}` in bindings))) {\n            variables.push(variable);\n          }\n        }\n        return false;\n      },\n      union(union: Algebra.Union): boolean {\n        // Determine variables in scope of the union branches that are not occurring in every branch\n        const scopedVariables = union.input.map(Util.inScopeVariables);\n        for (const variable of uniqTerms(scopedVariables.flat())) {\n          if (!scopedVariables.every(input => input.some(inputVar => inputVar.equals(variable)))) {\n            variables.push(variable);\n          }\n        }\n\n        return true;\n      },\n    });\n    return uniqTerms(variables);\n  }\n\n  /**\n   * Send a SPARQL query to a SPARQL endpoint and retrieve its bindings as a stream.\n   * @param {string} endpoint A SPARQL endpoint URL.\n   * @param {string} query A SPARQL query string.\n   * @param {RDF.Variable[]} variables The expected variables.\n   * @param {IActionContext} context The source context.\n   * @param undefVariables Variables that may have undefs.\n   * @return {BindingsStream} A stream of bindings.\n   */\n  public async queryBindingsRemote(\n    endpoint: string,\n    query: string,\n    variables: RDF.Variable[],\n    context: IActionContext,\n    undefVariables: RDF.Variable[],\n  ): Promise<BindingsStream> {\n    // Index undef variables\n    const undefVariablesIndex: Set<string> = new Set();\n    for (const undefVariable of undefVariables) {\n      undefVariablesIndex.add(undefVariable.value);\n    }\n\n    this.lastSourceContext = this.context.merge(context);\n    const rawStream = await this.endpointFetcher.fetchBindings(endpoint, query);\n    this.lastSourceContext = undefined;\n\n    return wrap<any>(rawStream, { autoStart: false, maxBufferSize: Number.POSITIVE_INFINITY })\n      .map<RDF.Bindings>((rawData: Record<string, RDF.Term>) => this.bindingsFactory.bindings(variables\n        .map((variable) => {\n          const value = rawData[`?${variable.value}`];\n          if (!undefVariablesIndex.has(variable.value) && !value) {\n            Actor.getContextLogger(this.context)?.warn(`The endpoint ${endpoint} failed to provide a binding for ${variable.value}.`);\n          }\n          return <[RDF.Variable, RDF.Term]>[ variable, value ];\n        })\n        .filter(([ _, v ]) => Boolean(v))));\n  }\n\n  public toString(): string {\n    return `QuerySourceSparql(${this.url})`;\n  }\n}\n"]}
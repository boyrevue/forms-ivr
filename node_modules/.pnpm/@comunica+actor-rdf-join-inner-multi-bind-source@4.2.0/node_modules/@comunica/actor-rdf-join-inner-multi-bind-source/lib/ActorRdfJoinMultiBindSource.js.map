{"version":3,"file":"ActorRdfJoinMultiBindSource.js","sourceRoot":"","sources":["ActorRdfJoinMultiBindSource.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  IActionRdfJoin,\n  IActorRdfJoinArgs,\n  IActorRdfJoinOutputInner,\n  IActorRdfJoinTestSideData,\n} from '@comunica/bus-rdf-join';\nimport { ActorRdfJoin } from '@comunica/bus-rdf-join';\nimport type { MediatorRdfJoinEntriesSort } from '@comunica/bus-rdf-join-entries-sort';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type { TestResult } from '@comunica/core';\nimport { passTestWithSideData, failTest, passTest } from '@comunica/core';\nimport type { IMediatorTypeJoinCoefficients } from '@comunica/mediatortype-join-coefficients';\nimport type {\n  IJoinEntryWithMetadata,\n  IQueryOperationResultBindings,\n  IQuerySourceWrapper,\n  IActionContext,\n  ComunicaDataFactory,\n} from '@comunica/types';\nimport { ChunkedIterator } from '@comunica/utils-iterator';\nimport { doesShapeAcceptOperation, getOperationSource } from '@comunica/utils-query-operation';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { UnionIterator } from 'asynciterator';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport { Factory } from 'sparqlalgebrajs';\n\n/**\n * A comunica Inner Multi Bind Source RDF Join Actor.\n */\nexport class ActorRdfJoinMultiBindSource extends ActorRdfJoin<IActorRdfJoinMultiBindSourceTestSideData> {\n  public readonly selectivityModifier: number;\n  public readonly blockSize: number;\n  public readonly mediatorJoinEntriesSort: MediatorRdfJoinEntriesSort;\n\n  public constructor(args: IActorRdfJoinInnerMultiBindSourceArgs) {\n    super(args, {\n      logicalType: 'inner',\n      physicalName: 'bind-source',\n      canHandleUndefs: true,\n    });\n  }\n\n  public async getOutput(\n    action: IActionRdfJoin,\n    sideData: IActorRdfJoinMultiBindSourceTestSideData,\n  ): Promise<IActorRdfJoinOutputInner> {\n    const dataFactory: ComunicaDataFactory = action.context.getSafe(KeysInitQuery.dataFactory);\n    const algebraFactory = new Factory(dataFactory);\n\n    // Order the entries so we can pick the first one (usually the one with the lowest cardinality)\n    const entries = sideData.entriesSorted;\n    this.logDebug(\n      action.context,\n      'First entry for Bind Join Source: ',\n      () => ({\n        entry: entries[0].operation,\n        cardinality: entries[0].metadata.cardinality,\n        order: entries[0].metadata.order,\n        availableOrders: entries[0].metadata.availableOrders,\n      }),\n    );\n\n    // Close the non-smallest streams\n    for (const [ i, element ] of entries.entries()) {\n      if (i !== 0) {\n        element.output.bindingsStream.close();\n      }\n    }\n\n    // Take the stream with the lowest cardinality\n    const smallestStream: IQueryOperationResultBindings = entries[0].output;\n    const smallestMetadata = entries[0].metadata;\n    const remainingEntries = [ ...entries ];\n    remainingEntries.splice(0, 1);\n\n    // Get source for remaining entries (guaranteed thanks to prior check in getJoinCoefficients())\n    const sourceWrapper = <IQuerySourceWrapper> getOperationSource(remainingEntries[0].operation);\n\n    // Determine the operation to pass\n    const operation = this.createOperationFromEntries(algebraFactory, remainingEntries);\n\n    // Slice the smallest stream into chunks according to the block size, so we avoid blocking too long.\n    const chunkedStreams: AsyncIterator<AsyncIterator<RDF.Bindings>> = new ChunkedIterator(\n      smallestStream.bindingsStream,\n      this.blockSize,\n      { autoStart: false },\n    );\n\n    // For each chunk, pass the query and the bindings to the source for execution\n    const bindingsStream = new UnionIterator(chunkedStreams.map(chunk => sourceWrapper.source.queryBindings(\n      operation,\n      sourceWrapper.context ? action.context.merge(sourceWrapper.context) : action.context,\n      { joinBindings: { bindings: chunk, metadata: smallestMetadata }},\n    )));\n\n    return {\n      result: {\n        type: 'bindings',\n        bindingsStream,\n        metadata: () => this.constructResultMetadata(entries, entries.map(entry => entry.metadata), action.context),\n      },\n      physicalPlanMetadata: {\n        bindIndex: sideData.entriesUnsorted.indexOf(entries[0]),\n      },\n    };\n  }\n\n  protected async sortJoinEntries(\n    entries: IJoinEntryWithMetadata[],\n    context: IActionContext,\n  ): Promise<TestResult<IJoinEntryWithMetadata[]>> {\n    const entriesTest = await ActorRdfJoin.sortJoinEntries(this.mediatorJoinEntriesSort, entries, context);\n    if (entriesTest.isFailed()) {\n      return entriesTest;\n    }\n    entries = entriesTest.get();\n\n    // Prioritize entries with modified operations, so these are not re-executed\n    entries = entries.sort((entryLeft, entryRight) => {\n      if (entryLeft.operationModified && !entryRight.operationModified) {\n        return -1;\n      }\n      return 0;\n    });\n\n    return passTest(entries);\n  }\n\n  public async getJoinCoefficients(\n    action: IActionRdfJoin,\n    sideData: IActorRdfJoinTestSideData,\n  ): Promise<TestResult<IMediatorTypeJoinCoefficients, IActorRdfJoinMultiBindSourceTestSideData>> {\n    let { metadatas } = sideData;\n\n    const dataFactory: ComunicaDataFactory = action.context.getSafe(KeysInitQuery.dataFactory);\n    const algebraFactory = new Factory(dataFactory);\n\n    // Order the entries so we can pick the first one (usually the one with the lowest cardinality)\n    const entriesUnsorted = action.entries.map((entry, i) => ({ ...entry, metadata: metadatas[i] }));\n    const entriesTest = await this.sortJoinEntries(entriesUnsorted, action.context);\n    if (entriesTest.isFailed()) {\n      return entriesTest;\n    }\n    const entriesSorted = entriesTest.get();\n    metadatas = entriesSorted.map(entry => entry.metadata);\n\n    const requestInitialTimes = ActorRdfJoin.getRequestInitialTimes(metadatas);\n    const requestItemTimes = ActorRdfJoin.getRequestItemTimes(metadatas);\n\n    // Determine first stream and remaining ones\n    const remainingEntries = [ ...entriesSorted ];\n    const remainingRequestInitialTimes = [ ...requestInitialTimes ];\n    const remainingRequestItemTimes = [ ...requestItemTimes ];\n    remainingEntries.splice(0, 1);\n    remainingRequestInitialTimes.splice(0, 1);\n    remainingRequestItemTimes.splice(0, 1);\n\n    // Reject binding on operations without sources\n    const sources = remainingEntries.map(entry => getOperationSource(entry.operation));\n    if (sources.some(source => !source)) {\n      return failTest(`Actor ${this.name} can not bind on remaining operations without source annotation`);\n    }\n\n    // Reject binding on operations with un-equal sources\n    if (sources.some(source => source !== sources[0])) {\n      return failTest(`Actor ${this.name} can not bind on remaining operations with non-equal source annotation`);\n    }\n\n    // Reject if the source can not handle bindings\n    const sourceWrapper: IQuerySourceWrapper = <IQuerySourceWrapper> sources[0];\n    const testingOperation = this.createOperationFromEntries(algebraFactory, remainingEntries);\n    const selectorShape = await sourceWrapper.source.getSelectorShape(action.context);\n    if (!doesShapeAcceptOperation(selectorShape, testingOperation, { joinBindings: true })) {\n      return failTest(`Actor ${this.name} detected a source that can not handle passing down join bindings`);\n    }\n\n    // Determine selectivities of smallest entry with all other entries\n    const selectivities = await Promise.all(remainingEntries\n      .map(async entry => (await this.mediatorJoinSelectivity.mediate({\n        entries: [ entriesSorted[0], entry ],\n        context: action.context,\n      })).selectivity * this.selectivityModifier));\n\n    // Determine coefficients for remaining entries\n    const cardinalityRemaining = remainingEntries\n      .map((entry, i) => entry.metadata.cardinality.value * selectivities[i])\n      .reduce((sum, element) => sum + element, 0);\n\n    return passTestWithSideData({\n      iterations: 1,\n      persistedItems: metadatas[0].cardinality.value,\n      blockingItems: metadatas[0].cardinality.value,\n      requestTime: requestInitialTimes[0] + metadatas[0].cardinality.value * requestItemTimes[0] +\n        requestInitialTimes[1] + cardinalityRemaining * requestItemTimes[1],\n    }, { ...sideData, entriesUnsorted, entriesSorted });\n  }\n\n  public createOperationFromEntries(\n    algebraFactory: Factory,\n    remainingEntries: IJoinEntryWithMetadata[],\n  ): Algebra.Operation {\n    if (remainingEntries.length === 1) {\n      return remainingEntries[0].operation;\n    }\n    return algebraFactory.createJoin(remainingEntries.map(entry => entry.operation), true);\n  }\n}\n\nexport interface IActorRdfJoinInnerMultiBindSourceArgs\n  extends IActorRdfJoinArgs<IActorRdfJoinMultiBindSourceTestSideData> {\n  /**\n   * Multiplier for selectivity values\n   * @range {double}\n   * @default {0.0001}\n   */\n  selectivityModifier: number;\n  /**\n   * The maximum amount of bindings to send to the source per block.\n   * @default {16}\n   */\n  blockSize: number;\n  /**\n   * The join entries sort mediator\n   */\n  mediatorJoinEntriesSort: MediatorRdfJoinEntriesSort;\n}\n\nexport interface IActorRdfJoinMultiBindSourceTestSideData extends IActorRdfJoinTestSideData {\n  entriesUnsorted: IJoinEntryWithMetadata[];\n  entriesSorted: IJoinEntryWithMetadata[];\n}\n"]}
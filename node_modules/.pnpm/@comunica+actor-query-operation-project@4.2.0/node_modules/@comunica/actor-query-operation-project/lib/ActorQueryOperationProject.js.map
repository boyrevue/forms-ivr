{"version":3,"file":"ActorQueryOperationProject.js","sourceRoot":"","sources":["ActorQueryOperationProject.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport { ActorQueryOperationTypedMediated } from '@comunica/bus-query-operation';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type { IActorTest, TestResult } from '@comunica/core';\nimport { passTestVoid } from '@comunica/core';\nimport type {\n  Bindings,\n  BindingsStream,\n  ComunicaDataFactory,\n  IActionContext,\n  IQueryOperationResult,\n  IQueryOperationResultBindings,\n  MetadataVariable,\n} from '@comunica/types';\nimport { BlankNodeBindingsScoped } from '@comunica/utils-data-factory';\nimport { getSafeBindings } from '@comunica/utils-query-operation';\nimport type * as RDF from '@rdfjs/types';\nimport type { Algebra } from 'sparqlalgebrajs';\n\n/**\n * A comunica Project Query Operation Actor.\n */\nexport class ActorQueryOperationProject extends ActorQueryOperationTypedMediated<Algebra.Project> {\n  public constructor(args: IActorQueryOperationTypedMediatedArgs) {\n    super(args, 'project');\n  }\n\n  public async testOperation(_operation: Algebra.Project, _context: IActionContext): Promise<TestResult<IActorTest>> {\n    return passTestVoid();\n  }\n\n  public async runOperation(operation: Algebra.Project, context: IActionContext):\n  Promise<IQueryOperationResult> {\n    const dataFactory: ComunicaDataFactory = context.getSafe(KeysInitQuery.dataFactory);\n\n    // Resolve the input\n    const output: IQueryOperationResultBindings = getSafeBindings(\n      await this.mediatorQueryOperation.mediate({ operation: operation.input, context }),\n    );\n\n    // Index variables\n    const outputMetadata = await output.metadata();\n    const variablesOutputIndexed: Record<string, MetadataVariable> = Object\n      .fromEntries(outputMetadata.variables.map(entry => [ entry.variable.value, entry ]));\n    const variablesOperation: MetadataVariable[] = operation.variables.map(v => ({ variable: v, canBeUndef: false }));\n    const variablesOperationIndexed: Record<string, MetadataVariable> = Object\n      .fromEntries(variablesOperation.map(entry => [ entry.variable.value, entry ]));\n\n    // Find all variables that should be deleted from the input stream.\n    const deleteVariables = outputMetadata.variables\n      .filter(variable => !(variable.variable.value in variablesOperationIndexed));\n\n    // Determine if variables can be undef\n    const variablesOutput: MetadataVariable[] = variablesOperation.map(variable => ({\n      variable: variable.variable,\n      canBeUndef: !(variable.variable.value in variablesOutputIndexed) ||\n        variablesOutputIndexed[variable.variable.value].canBeUndef,\n    }));\n\n    // Make sure the project variables are the only variables that are present in the bindings.\n    let bindingsStream: BindingsStream = deleteVariables.length === 0 ?\n      output.bindingsStream :\n      output.bindingsStream.map((bindings: Bindings) => {\n        for (const deleteVariable of deleteVariables) {\n          bindings = bindings.delete(deleteVariable.variable);\n        }\n        return bindings;\n      });\n\n    // Make sure that blank nodes with same labels are not reused over different bindings, as required by SPARQL 1.1.\n    // Required for the BNODE() function: https://www.w3.org/TR/sparql11-query/#func-bnode\n    // When we have a scoped blank node, make sure the skolemized value is maintained.\n    let blankNodeCounter = 0;\n    bindingsStream = bindingsStream.map((bindings: Bindings) => {\n      blankNodeCounter++;\n      const scopedBlankNodesCache = new Map<string, RDF.BlankNode>();\n      return bindings.map((term) => {\n        if (term instanceof BlankNodeBindingsScoped) {\n          let scopedBlankNode = scopedBlankNodesCache.get(term.value);\n          if (!scopedBlankNode) {\n            scopedBlankNode = dataFactory.blankNode(`${term.value}${blankNodeCounter}`);\n            scopedBlankNodesCache.set(term.value, scopedBlankNode);\n          }\n          return scopedBlankNode;\n        }\n        return term;\n      });\n    });\n\n    return {\n      type: 'bindings',\n      bindingsStream,\n      metadata: async() => ({ ...outputMetadata, variables: variablesOutput }),\n    };\n  }\n}\n"]}
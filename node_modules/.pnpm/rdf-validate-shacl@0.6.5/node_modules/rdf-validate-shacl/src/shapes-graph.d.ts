import type { NamedNode, Term } from '@rdfjs/types';
import type { AnyPointer, GraphPointer } from 'clownface';
import type SHACLValidator from '../index.js';
import NodeSet from './node-set.js';
import type { ShaclPropertyPath } from './property-path.js';
import type { ValidationFunction, Validator } from './validation-engine.js';
declare class ShapesGraph {
    context: SHACLValidator;
    private readonly _components;
    private readonly _parametersMap;
    private readonly _shapes;
    private _shapeNodesWithConstraints;
    private _shapesWithTarget;
    constructor(context: SHACLValidator);
    getComponentWithParameter(parameter: Term): ConstraintComponent | undefined;
    getShape(shapeNode: Term): Shape;
    get shapeNodesWithConstraints(): Term[];
    get shapesWithTarget(): Shape[];
}
export declare class Constraint {
    readonly shape: Shape;
    readonly component: ConstraintComponent;
    shapeNodePointer: AnyPointer;
    readonly paramValue: Term;
    private _parameterValues;
    private inNodeSet;
    constructor(shape: Shape, component: ConstraintComponent, shapesGraph: AnyPointer, _parameterValuesOrSingleParam: Term | Map<Term, Term>);
    get validate(): (focusNode: Term, valueNode: Term) => boolean | void | string[] | import("./validation-engine.js").ValidationResult[];
    static fromShape(shape: Shape, component: ConstraintComponent, shapesGraph: AnyPointer): Generator<Constraint, void, unknown>;
    getParameterValue(param: Term): Term;
    get pathObject(): ShaclPropertyPath;
    get validationFunction(): (focusNode: Term, valueNode: Term, constraint: Constraint) => ReturnType<ValidationFunction>;
    get isValidationFunctionGeneric(): boolean;
    get componentMessages(): [] | [string];
    get nodeSet(): NodeSet;
}
declare class ConstraintComponent {
    readonly node: NamedNode;
    readonly context: SHACLValidator;
    nodePointer: GraphPointer;
    parameters: Term[];
    parameterNodes: unknown[];
    requiredParameters: Term[];
    optionals: Record<string, unknown>;
    validator: Validator | undefined;
    nodeValidationFunction: (focusNode: Term, valueNode: Term, constraint: Constraint) => ReturnType<ValidationFunction>;
    nodeValidationFunctionGeneric: boolean;
    nodeValidationMessage: string | undefined;
    propertyValidationFunction: (focusNode: Term, valueNode: Term, constraint: Constraint) => ReturnType<ValidationFunction>;
    propertyValidationFunctionGeneric: boolean;
    propertyValidationMessage: string | undefined;
    constructor(node: NamedNode, context: SHACLValidator, shaclVocabulary: AnyPointer);
    getMessages(shape: Shape): [string] | [];
    isComplete(parameterValues: Map<Term, unknown>): boolean;
}
export declare class Shape {
    context: SHACLValidator;
    shapeNode: Term;
    shapeNodePointer: GraphPointer;
    severity: Term;
    deactivated: boolean;
    path: GraphPointer | undefined;
    pathObject: ShaclPropertyPath | null;
    constraints: Constraint[];
    constructor(context: SHACLValidator, shapeNode: Term);
    get isPropertyShape(): boolean;
    overridePath(path: ShaclPropertyPath): Shape;
    getTargetNodes(dataGraph: AnyPointer): Term[];
    getValueNodes(focusNode: Term, dataGraph: AnyPointer): Term[];
}
export default ShapesGraph;

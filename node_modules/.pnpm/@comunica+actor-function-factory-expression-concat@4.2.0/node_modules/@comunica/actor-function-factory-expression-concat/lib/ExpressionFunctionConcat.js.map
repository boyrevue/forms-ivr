{"version":3,"file":"ExpressionFunctionConcat.js","sourceRoot":"","sources":["ExpressionFunctionConcat.ts"],"names":[],"mappings":";;;AAAA,yEAAwE;AACxE,+DAAmF;AAMnF,qFAM8C;AAE9C;;GAEG;AACH,MAAa,wBAAyB,SAAQ,6CAAsB;IAClE;QACE,KAAK,CAAC;YACJ,KAAK,EAAE,MAAM,CAAC,iBAAiB;YAC/B,QAAQ,EAAE,2CAAc,CAAC,MAAM;YAC/B,KAAK,EAAE,KAAK,EAAC,OAAqB,EAA2B,EAAE;gBAC7D,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,QAAQ,EAAE,GAAG,OAAO,CAAC;gBAC5C,MAAM,KAAK,GAA+B,IAAI;qBAC3C,GAAG,CAAC,KAAK,EAAC,IAAI,EAAC,EAAE,CAAC,QAAQ,CAAC,6BAA6B,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;qBACxE,GAAG,CAAC,KAAK,EAAC,KAAK,EAAE,EAAE;oBAClB,MAAM,SAAS,GAAG,wBAAwB,CAAC,UAAU,CAAC,MAAM,CAC1D,CAAE,MAAM,KAAK,CAAE,EACf,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,yCAAuB,CAAC,iBAAiB,CAAC,EACnE,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,+BAAa,CAAC,sBAAsB,CAAC,CAC/D,CAAC;oBACF,IAAI,CAAC,SAAS,EAAE,CAAC;wBACf,MAAM,IAAI,iDAAoB,CAAC,IAAI,EAAE,2CAAc,CAAC,MAAM,CAAC,CAAC;oBAC9D,CAAC;oBACD,OAAyB,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAE,MAAM,KAAK,CAAE,CAAC,CAAC;gBAChE,CAAC,CAAC,CAAC;gBACL,MAAM,IAAI,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;gBACtC,MAAM,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;gBAChD,MAAM,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;gBAChC,MAAM,IAAI,GAAG,wBAAwB,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC;gBACxF,OAAO,IAAI,CAAC,CAAC,CAAC,IAAA,uCAAU,EAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,IAAA,mCAAM,EAAC,MAAM,CAAC,CAAC;YAC1D,CAAC;SACF,CAAC,CAAC;IACL,CAAC;IAQO,MAAM,CAAC,YAAY,CAAC,IAAuB;QACjD,OAAO,IAAI,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,QAAQ,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;IACjF,CAAC;;AArCH,4DAsCC;AATC;;GAEG;AACqB,mCAAU,GAAiB,IAAA,oCAAO,EAAC,2CAAc,CAAC,MAAM,CAAC,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC;KAC9G,OAAO,EAAE,CAAC","sourcesContent":["import { ExpressionFunctionBase } from '@comunica/bus-function-factory';\nimport { KeysExpressionEvaluator, KeysInitQuery } from '@comunica/context-entries';\nimport type { IEvalContext, TermExpression } from '@comunica/types';\nimport type {\n  Literal,\n  OverloadTree,\n} from '@comunica/utils-expression-evaluator';\nimport {\n  declare,\n  InvalidArgumentTypes,\n  langString,\n  SparqlOperator,\n  string,\n} from '@comunica/utils-expression-evaluator';\n\n/**\n * https://www.w3.org/TR/sparql11-query/#func-concat\n */\nexport class ExpressionFunctionConcat extends ExpressionFunctionBase {\n  public constructor() {\n    super({\n      arity: Number.POSITIVE_INFINITY,\n      operator: SparqlOperator.CONCAT,\n      apply: async(context: IEvalContext): Promise<TermExpression> => {\n        const { args, mapping, exprEval } = context;\n        const pLits: Promise<Literal<string>>[] = args\n          .map(async expr => exprEval.evaluatorExpressionEvaluation(expr, mapping))\n          .map(async(pTerm) => {\n            const operation = ExpressionFunctionConcat.concatTree.search(\n              [ await pTerm ],\n              exprEval.context.getSafe(KeysExpressionEvaluator.superTypeProvider),\n              exprEval.context.getSafe(KeysInitQuery.functionArgumentsCache),\n            );\n            if (!operation) {\n              throw new InvalidArgumentTypes(args, SparqlOperator.CONCAT);\n            }\n            return <Literal<string>> operation(exprEval)([ await pTerm ]);\n          });\n        const lits = await Promise.all(pLits);\n        const strings = lits.map(lit => lit.typedValue);\n        const joined = strings.join('');\n        const lang = ExpressionFunctionConcat.langAllEqual(lits) ? lits[0].language : undefined;\n        return lang ? langString(joined, lang) : string(joined);\n      },\n    });\n  }\n\n  /**\n   * This OverloadTree with the constant function will handle both type promotion and subtype-substitution\n   */\n  private static readonly concatTree: OverloadTree = declare(SparqlOperator.CONCAT).onStringly1(() => expr => expr)\n    .collect();\n\n  private static langAllEqual(lits: Literal<string>[]): boolean {\n    return lits.length > 0 && lits.every(lit => lit.language === lits[0].language);\n  }\n}\n"]}
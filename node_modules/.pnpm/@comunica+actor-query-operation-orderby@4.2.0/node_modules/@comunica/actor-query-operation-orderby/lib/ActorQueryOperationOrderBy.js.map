{"version":3,"file":"ActorQueryOperationOrderBy.js","sourceRoot":"","sources":["ActorQueryOperationOrderBy.ts"],"names":[],"mappings":"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","sourcesContent":["import type { MediatorExpressionEvaluatorFactory } from '@comunica/bus-expression-evaluator-factory';\nimport type { IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport { ActorQueryOperationTypedMediated } from '@comunica/bus-query-operation';\nimport type { MediatorTermComparatorFactory } from '@comunica/bus-term-comparator-factory';\nimport type { IActorTest, TestResult } from '@comunica/core';\nimport { passTestVoid } from '@comunica/core';\nimport type { Bindings, IActionContext, IQueryOperationResult } from '@comunica/types';\nimport { isExpressionError } from '@comunica/utils-expression-evaluator';\nimport { getSafeBindings } from '@comunica/utils-query-operation';\nimport type { Term } from '@rdfjs/types';\nimport { Algebra } from 'sparqlalgebrajs';\nimport { SortIterator } from './SortIterator';\n\n/**\n * A comunica OrderBy Query Operation Actor.\n */\nexport class ActorQueryOperationOrderBy extends ActorQueryOperationTypedMediated<Algebra.OrderBy> {\n  private readonly window: number;\n  private readonly mediatorExpressionEvaluatorFactory: MediatorExpressionEvaluatorFactory;\n  private readonly mediatorTermComparatorFactory: MediatorTermComparatorFactory;\n\n  public constructor(args: IActorQueryOperationOrderBySparqleeArgs) {\n    super(args, 'orderby');\n    this.window = args.window ?? Number.POSITIVE_INFINITY;\n    this.mediatorExpressionEvaluatorFactory = args.mediatorExpressionEvaluatorFactory;\n    this.mediatorTermComparatorFactory = args.mediatorTermComparatorFactory;\n  }\n\n  public async testOperation(): Promise<TestResult<IActorTest>> {\n    return passTestVoid();\n  }\n\n  public async runOperation(operation: Algebra.OrderBy, context: IActionContext):\n  Promise<IQueryOperationResult> {\n    const outputRaw = await this.mediatorQueryOperation.mediate({ operation: operation.input, context });\n    const output = getSafeBindings(outputRaw);\n\n    const options = { window: this.window };\n    let { bindingsStream } = output;\n\n    // Sorting backwards since the first one is the most important therefore should be ordered last.\n    const orderByEvaluator = await this.mediatorTermComparatorFactory.mediate({ context });\n\n    for (let i = operation.expressions.length - 1; i >= 0; i--) {\n      let expr = operation.expressions[i];\n      const isAscending = this.isAscending(expr);\n      expr = this.extractSortExpression(expr);\n      // Transform the stream by annotating it with the expr result\n      const evaluator = await this.mediatorExpressionEvaluatorFactory\n        .mediate({ algExpr: expr, context });\n      interface IAnnotatedBinding {\n        bindings: Bindings;\n        result: Term | undefined;\n      }\n\n      const transform = async(bindings: Bindings, next: any, push: (result: IAnnotatedBinding) => void):\n      Promise<void> => {\n        try {\n          const result = await evaluator.evaluate(bindings);\n          push({ bindings, result });\n        } catch (error: unknown) {\n          // We ignore all Expression errors.\n          // Other errors (likely programming mistakes) are still propagated.\n          // I can't recall where this is defined in the spec.\n          if (!isExpressionError(<Error> error)) {\n            bindingsStream.emit('error', error);\n          }\n          push({ bindings, result: undefined });\n        }\n        next();\n      };\n      // eslint-disable-next-line ts/no-misused-promises\n      const transformedStream = bindingsStream.transform<IAnnotatedBinding>({ transform });\n\n      // Sort the annoted stream\n      const sortedStream = new SortIterator(transformedStream, (left, right) => {\n        let compare = orderByEvaluator.orderTypes(left.result, right.result);\n        if (!isAscending) {\n          compare *= -1;\n        }\n        return compare;\n      }, options);\n\n      // Remove the annotation\n      bindingsStream = sortedStream.map(({ bindings }) => bindings);\n    }\n\n    return {\n      type: 'bindings',\n      bindingsStream,\n      metadata: output.metadata,\n    };\n  }\n\n  // Remove descending operator if necessary\n  private extractSortExpression(expr: Algebra.Expression): Algebra.Expression {\n    const { expressionType, operator } = expr;\n    if (expressionType !== Algebra.expressionTypes.OPERATOR) {\n      return expr;\n    }\n    return operator === 'desc' ?\n      expr.args[0] :\n      expr;\n  }\n\n  private isAscending(expr: Algebra.Expression): boolean {\n    const { expressionType, operator } = expr;\n    if (expressionType !== Algebra.expressionTypes.OPERATOR) {\n      return true;\n    }\n    return operator !== 'desc';\n  }\n}\n\n/**\n * The window parameter determines how many of the elements to consider when sorting.\n */\nexport interface IActorQueryOperationOrderBySparqleeArgs extends IActorQueryOperationTypedMediatedArgs {\n  /**\n   * The size of the window for the sort iterator.\n   * @range {integer}\n   */\n  window?: number;\n  mediatorExpressionEvaluatorFactory: MediatorExpressionEvaluatorFactory;\n  mediatorTermComparatorFactory: MediatorTermComparatorFactory;\n}\n"]}
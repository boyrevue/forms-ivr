{"version":3,"file":"ActorHttpRetry.js","sourceRoot":"","sources":["ActorHttpRetry.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IActionHttp, IActorHttpOutput, IActorHttpArgs, MediatorHttp } from '@comunica/bus-http';\nimport { ActorHttp } from '@comunica/bus-http';\nimport type { ActorHttpInvalidateListenable, IActionHttpInvalidate } from '@comunica/bus-http-invalidate';\nimport { KeysHttp } from '@comunica/context-entries';\nimport { ActionContextKey, passTest, failTest } from '@comunica/core';\nimport type { TestResult } from '@comunica/core';\nimport type { IMediatorTypeTime } from '@comunica/mediatortype-time';\n\nexport class ActorHttpRetry extends ActorHttp {\n  private readonly activeDelays: Record<string, { date: Date; timeout: NodeJS.Timeout }>;\n  private readonly httpInvalidator: ActorHttpInvalidateListenable;\n  private readonly mediatorHttp: MediatorHttp;\n\n  // Expression that matches dates expressed in the HTTP Date header format\n  // eslint-disable-next-line max-len\n  private static readonly dateRegex = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), [0-9]{2} (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) [0-9]{4} [0-9]{2}:[0-9]{2}:[0-9]{2} GMT$/u;\n\n  // Expression that matches numeric values of Retry-After\n  private static readonly numberRegex = /^[0-9]+$/u;\n\n  // Context key to indicate that the actor has already wrapped the given request\n  private static readonly keyWrapped = new ActionContextKey<boolean>('urn:comunica:actor-http-retry#wrapped');\n\n  public constructor(args: IActorHttpQueueArgs) {\n    super(args);\n    this.activeDelays = {};\n    this.httpInvalidator = args.httpInvalidator;\n    this.httpInvalidator.addInvalidateListener(action => this.handleHttpInvalidateEvent(action));\n    this.mediatorHttp = args.mediatorHttp;\n  }\n\n  public async test(action: IActionHttp): Promise<TestResult<IMediatorTypeTime>> {\n    if (action.context.has(ActorHttpRetry.keyWrapped)) {\n      return failTest(`${this.name} can only wrap a request once`);\n    }\n    const retryCount = action.context.get(KeysHttp.httpRetryCount);\n    if (!retryCount || retryCount < 1) {\n      return failTest(`${this.name} requires a retry count greater than zero to function`);\n    }\n    return passTest({ time: 0 });\n  }\n\n  public async run(action: IActionHttp): Promise<IActorHttpOutput> {\n    const url = ActorHttp.getInputUrl(action.input);\n\n    // Attempt once + the number of retries specified by the user\n    const attemptLimit = action.context.getSafe(KeysHttp.httpRetryCount) + 1;\n    const retryDelayFallback = action.context.get(KeysHttp.httpRetryDelayFallback) ?? 0;\n    const retryDelayLimit = action.context.get(KeysHttp.httpRetryDelayLimit);\n    const retryStatusCodes = action.context.get(KeysHttp.httpRetryStatusCodes);\n\n    for (let attempt = 1; attempt <= attemptLimit; attempt++) {\n      const retryDelay = url.host in this.activeDelays ?\n        this.activeDelays[url.host].date.getTime() - Date.now() :\n        retryDelayFallback;\n\n      if (retryDelayLimit && retryDelay > retryDelayLimit) {\n        this.logWarn(action.context, 'Requested delay exceeds the limit', () => ({\n          url: url.href,\n          delay: retryDelay,\n          delayDate: this.activeDelays[url.host].date.toISOString(),\n          delayLimit: retryDelayLimit,\n          currentAttempt: `${attempt} / ${attemptLimit}`,\n        }));\n        break;\n      } else if (retryDelay > 0 && attempt > 1) {\n        this.logDebug(action.context, 'Delaying request', () => ({\n          url: url.href,\n          delay: retryDelay,\n          currentAttempt: `${attempt} / ${attemptLimit}`,\n        }));\n        await ActorHttpRetry.sleep(retryDelay);\n      }\n\n      const response = await this.mediatorHttp.mediate({\n        ...action,\n        context: action.context.set(ActorHttpRetry.keyWrapped, true),\n      });\n\n      if (response.ok) {\n        return response;\n      }\n\n      if (retryStatusCodes && retryStatusCodes.includes(response.status)) {\n        this.logDebug(action.context, 'Status code in force retry list, forcing retry', () => ({\n          url: url.href,\n          status: response.status,\n          statusText: response.statusText,\n          currentAttempt: `${attempt} / ${attemptLimit}`,\n        }));\n        continue;\n      }\n\n      if (response.status === 504) {\n        // When the server is acting as a proxy and the source times it, it makes sense to retry\n        // with the hope that the source server replies within the timeout\n        this.logDebug(action.context, 'Received proxy timeout', () => ({\n          url: url.href,\n          status: response.status,\n          statusText: response.statusText,\n          currentAttempt: `${attempt} / ${attemptLimit}`,\n        }));\n        continue;\n      }\n\n      if (\n        // Status codes 429 (Too Many Requests) and 503 (Temporarily Unavailable) can have Retry-After\n        response.status === 429 || response.status === 503 ||\n        // DBPedia SPARQL endpoint uses 405 instead of 429 and sends a Retry-After with it to indicate rate limits\n        (response.status === 405 && response.headers.has('retry-after'))\n      ) {\n        const retryAfterHeader = response.headers.get('retry-after');\n\n        if (retryAfterHeader) {\n          const retryAfter = ActorHttpRetry.parseRetryAfterHeader(retryAfterHeader);\n          if (retryAfter) {\n            // Clear any previous clean-up timers for the host\n            if (url.host in this.activeDelays) {\n              clearTimeout(this.activeDelays[url.host].timeout);\n            }\n            // Record the current host-specific active delay, and add a clean-up timer for this new delay\n            this.activeDelays[url.host] = {\n              date: retryAfter,\n              timeout: setTimeout(() => delete this.activeDelays[url.host], retryAfter.getTime() - Date.now()),\n            };\n          } else {\n            this.logDebug(action.context, 'Invalid Retry-After header value from server', () => ({\n              url: url.href,\n              status: response.status,\n              statusText: response.statusText,\n              retryAfterHeader,\n              currentAttempt: `${attempt} / ${attemptLimit}`,\n            }));\n          }\n        }\n\n        this.logDebug(action.context, 'Server temporarily unavailable', () => ({\n          url: url.href,\n          status: response.status,\n          statusText: response.statusText,\n          currentAttempt: `${attempt} / ${attemptLimit}`,\n        }));\n\n        continue;\n      }\n\n      if (response.status >= 400 && response.status < 500) {\n        // When the server reports a missing document, insufficient permissions, bad request or other error\n        // in the 400 range except for the rate limit, it makes sense to skip further retries.\n        // Sending the same, potentially invalid request for missing or inaccessible resources is unlikely to succeed.\n        this.logDebug(action.context, 'Server reported client-side error', () => ({\n          url: url.href,\n          status: response.status,\n          statusText: response.statusText,\n          currentAttempt: `${attempt} / ${attemptLimit}`,\n        }));\n        break;\n      }\n\n      if (response.status >= 500 && response.status < 600) {\n        // When a server-side error is encountered, it will likely not be fixable client-side,\n        // and sending the same request again will most likely result in the same server-side failure.\n        // Therefore, it makes sense not to retry on such errors at all.\n        this.logDebug(action.context, 'Server-side error encountered, terminating', () => ({\n          url: url.href,\n          status: response.status,\n          statusText: response.statusText,\n          currentAttempt: `${attempt} / ${attemptLimit}`,\n        }));\n        break;\n      }\n\n      // Error codes not specifically handled should be logged as-is for user to notice\n      this.logDebug(action.context, 'Request failed', () => ({\n        url: url.href,\n        status: response.status,\n        statusText: response.statusText,\n        currentAttempt: `${attempt} / ${attemptLimit}`,\n      }));\n    }\n\n    throw new Error(`Request failed: ${url.href}`);\n  }\n\n  /**\n   * Sleeps for the specified amount of time, using a timeout\n   * @param {number} ms The amount of milliseconds to sleep\n   */\n  public static async sleep(ms: number): Promise<void> {\n    if (ms > 0) {\n      await new Promise(resolve => setTimeout(resolve, ms));\n    }\n  }\n\n  /**\n   * Parses a Retry-After HTTP header value following the specification:\n   * https://httpwg.org/specs/rfc9110.html#field.retry-after\n   * @param {string} retryAfter The raw header value as string\n   * @returns The parsed Date object, or undefined in case of invalid header value\n   */\n  public static parseRetryAfterHeader(retryAfter: string): Date | undefined {\n    if (ActorHttpRetry.numberRegex.test(retryAfter)) {\n      return new Date(Date.now() + Number.parseInt(retryAfter, 10) * 1_000);\n    }\n    if (ActorHttpRetry.dateRegex.test(retryAfter)) {\n      return new Date(retryAfter);\n    }\n  }\n\n  /**\n   * Handles HTTP cache invalidation events.\n   * @param {IActionHttpInvalidate} action The invalidation action\n   */\n  public handleHttpInvalidateEvent(action: IActionHttpInvalidate): void {\n    const invalidatedHost = action.url ? new URL(action.url).host : undefined;\n    for (const host of Object.keys(this.activeDelays)) {\n      if (!invalidatedHost || host === invalidatedHost) {\n        clearTimeout(this.activeDelays[host].timeout);\n        delete this.activeDelays[host];\n      }\n    }\n  }\n}\n\nexport interface IActorHttpQueueArgs extends IActorHttpArgs {\n  /**\n   * The HTTP mediator.\n   */\n  mediatorHttp: MediatorHttp;\n  /* eslint-disable max-len */\n  /**\n   * An actor that listens to HTTP invalidation events\n   * @default {<default_invalidator> a <npmd:@comunica/bus-http-invalidate/^4.0.0/components/ActorHttpInvalidateListenable.jsonld#ActorHttpInvalidateListenable>}\n   */\n  httpInvalidator: ActorHttpInvalidateListenable;\n  /* eslint-enable max-len */\n}\n"]}
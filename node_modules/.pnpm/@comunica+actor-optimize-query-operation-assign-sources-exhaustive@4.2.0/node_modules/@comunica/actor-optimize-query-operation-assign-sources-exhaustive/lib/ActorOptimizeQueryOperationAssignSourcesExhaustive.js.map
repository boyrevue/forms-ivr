{"version":3,"file":"ActorOptimizeQueryOperationAssignSourcesExhaustive.js","sourceRoot":"","sources":["ActorOptimizeQueryOperationAssignSourcesExhaustive.ts"],"names":[],"mappings":";;;AAKA,yFAAqF;AACrF,yEAAyE;AACzE,+DAAkG;AAElG,yCAA8C;AAE9C,2EAAkG;AAClG,qDAAyD;AAEzD;;GAEG;AACH,MAAa,kDAAmD,SAAQ,0DAA2B;IACjG,YAAmB,IAAsC;QACvD,KAAK,CAAC,IAAI,CAAC,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,OAAsC;QACtD,OAAO,IAAA,mBAAY,GAAE,CAAC;IACxB,CAAC;IAEM,KAAK,CAAC,GAAG,CAAC,MAAqC;QACpD,MAAM,WAAW,GAAwB,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,+BAAa,CAAC,WAAW,CAAC,CAAC;QAC3F,MAAM,cAAc,GAAG,IAAI,yBAAO,CAAC,WAAW,CAAC,CAAC;QAEhD,MAAM,OAAO,GAA0B,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,oCAAkB,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC;QACjG,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACzB,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC,SAAS,EAAE,OAAO,EAAE,MAAM,CAAC,OAAO,EAAE,CAAC;QAClE,CAAC;QACD,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACzB,MAAM,aAAa,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;YACjC,MAAM,WAAW,GAAiC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,oCAAkB,CAAC,WAAW,CAAC,CAAC;YACrG,IAAI,CAAC,WAAW,IAAI,aAAa,CAAC,MAAM,CAAC,cAAc,KAAK,IAAA,8CAAuB,EAAC,WAAW,CAAC,EAAE,CAAC;gBACjG,IAAI,CAAC;oBACH,MAAM,KAAK,GAAG,MAAM,aAAa,CAAC,MAAM,CAAC,gBAAgB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;oBAC1E,IAAI,IAAA,gDAAwB,EAAC,KAAK,EAAE,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC;wBACtD,OAAO;4BACL,SAAS,EAAE,IAAA,6CAAqB,EAAC,MAAM,CAAC,SAAS,EAAE,aAAa,CAAC;4BACjE,OAAO,EAAE,MAAM,CAAC,OAAO;yBACxB,CAAC;oBACJ,CAAC;gBACH,CAAC;gBAAC,MAAM,CAAC;oBACP,uEAAuE;oBACvE,kDAAkD;gBACpD,CAAC;YACH,CAAC;QACH,CAAC;QACD,OAAO;YACL,SAAS,EAAE,IAAI,CAAC,gBAAgB,CAAC,cAAc,EAAE,MAAM,CAAC,SAAS,EAAE,OAAO,CAAC;YAC3E,2GAA2G;YAC3G,iEAAiE;YACjE,OAAO,EAAE,MAAM,CAAC,OAAO;iBACpB,MAAM,CAAC,+BAAa,CAAC,WAAW,CAAC;SACrC,CAAC;IACJ,CAAC;IAED;;;;;;;OAOG;IACI,gBAAgB,CACrB,cAAuB,EACvB,SAA4B,EAC5B,OAA8B;QAE9B,4CAA4C;QAC5C,MAAM,IAAI,GAAG,IAAI,CAAC;QAClB,OAAO,sBAAI,CAAC,YAAY,CAAC,SAAS,EAAE;YAClC,CAAC,yBAAO,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,YAAY,EAAE,OAAO;gBAC3C,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;oBACzB,OAAO;wBACL,MAAM,EAAE,IAAA,6CAAqB,EAAC,YAAY,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;wBACvD,OAAO,EAAE,KAAK;qBACf,CAAC;gBACJ,CAAC;gBACD,OAAO;oBACL,MAAM,EAAE,OAAO,CAAC,WAAW,CAAC,OAAO;yBAChC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,IAAA,6CAAqB,EAAC,YAAY,EAAE,MAAM,CAAC,CAAC,CAAC;oBAC9D,OAAO,EAAE,KAAK;iBACf,CAAC;YACJ,CAAC;YACD,CAAC,yBAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,YAAY,EAAE,OAAO;gBACxC,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;oBACzB,OAAO;wBACL,MAAM,EAAE,IAAA,6CAAqB,EAAC,YAAY,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;wBACvD,OAAO,EAAE,KAAK;qBACf,CAAC;gBACJ,CAAC;gBACD,OAAO;oBACL,MAAM,EAAE,OAAO,CAAC,SAAS,CAAC,OAAO;yBAC9B,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,IAAA,6CAAqB,EAAC,YAAY,EAAE,MAAM,CAAC,CAAC,CAAC;oBAC9D,OAAO,EAAE,KAAK;iBACf,CAAC;YACJ,CAAC;YACD,CAAC,yBAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,YAAY,EAAE,OAAO;gBACvC,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;oBACzB,OAAO;wBACL,MAAM,EAAE,IAAA,6CAAqB,EAAC,YAAY,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;wBACvD,OAAO,EAAE,KAAK;qBACf,CAAC;gBACJ,CAAC;gBACD,OAAO;oBACL,MAAM,EAAE,OAAO,CAAC,SAAS,CAAC,OAAO;yBAC9B,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,IAAA,6CAAqB,EAAC,YAAY,EAAE,MAAM,CAAC,CAAC,CAAC;oBAC9D,OAAO,EAAE,KAAK;iBACf,CAAC;YACJ,CAAC;YACD,CAAC,yBAAO,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,YAAY;gBAClC,OAAO;oBACL,MAAM,EAAE,YAAY;oBACpB,OAAO,EAAE,KAAK;iBACf,CAAC;YACJ,CAAC;YACD,CAAC,yBAAO,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,YAAY,EAAE,OAAO;gBAC7C,OAAO;oBACL,MAAM,EAAE,OAAO,CAAC,eAAe,CAC7B,IAAI,CAAC,gBAAgB,CAAC,cAAc,EAAE,YAAY,CAAC,KAAK,EAAE,OAAO,CAAC,EAClE,YAAY,CAAC,QAAQ,CACtB;oBACD,OAAO,EAAE,KAAK;iBACf,CAAC;YACJ,CAAC;YACD,CAAC,yBAAO,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC,YAAY,EAAE,OAAO;gBACjD,OAAO;oBACL,MAAM,EAAE,OAAO,CAAC,kBAAkB,CAChC,YAAY,CAAC,MAAM,EACnB,YAAY,CAAC,MAAM,EACnB,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,cAAc,EAAE,YAAY,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,CACpG;oBACD,OAAO,EAAE,KAAK;iBACf,CAAC;YACJ,CAAC;SACF,EAAE,cAAc,CAAC,CAAC;IACrB,CAAC;CACF;AA9HD,gHA8HC","sourcesContent":["import type {\n  IActionOptimizeQueryOperation,\n  IActorOptimizeQueryOperationOutput,\n  IActorOptimizeQueryOperationArgs,\n} from '@comunica/bus-optimize-query-operation';\nimport { ActorOptimizeQueryOperation } from '@comunica/bus-optimize-query-operation';\nimport { getDataDestinationValue } from '@comunica/bus-rdf-update-quads';\nimport { KeysInitQuery, KeysQueryOperation, KeysRdfUpdateQuads } from '@comunica/context-entries';\nimport type { IActorTest, TestResult } from '@comunica/core';\nimport { passTestVoid } from '@comunica/core';\nimport type { ComunicaDataFactory, IDataDestination, IQuerySourceWrapper } from '@comunica/types';\nimport { assignOperationSource, doesShapeAcceptOperation } from '@comunica/utils-query-operation';\nimport { Algebra, Factory, Util } from 'sparqlalgebrajs';\n\n/**\n * A comunica Assign Sources Exhaustive Optimize Query Operation Actor.\n */\nexport class ActorOptimizeQueryOperationAssignSourcesExhaustive extends ActorOptimizeQueryOperation {\n  public constructor(args: IActorOptimizeQueryOperationArgs) {\n    super(args);\n  }\n\n  public async test(_action: IActionOptimizeQueryOperation): Promise<TestResult<IActorTest>> {\n    return passTestVoid();\n  }\n\n  public async run(action: IActionOptimizeQueryOperation): Promise<IActorOptimizeQueryOperationOutput> {\n    const dataFactory: ComunicaDataFactory = action.context.getSafe(KeysInitQuery.dataFactory);\n    const algebraFactory = new Factory(dataFactory);\n\n    const sources: IQuerySourceWrapper[] = action.context.get(KeysQueryOperation.querySources) ?? [];\n    if (sources.length === 0) {\n      return { operation: action.operation, context: action.context };\n    }\n    if (sources.length === 1) {\n      const sourceWrapper = sources[0];\n      const destination: IDataDestination | undefined = action.context.get(KeysRdfUpdateQuads.destination);\n      if (!destination || sourceWrapper.source.referenceValue === getDataDestinationValue(destination)) {\n        try {\n          const shape = await sourceWrapper.source.getSelectorShape(action.context);\n          if (doesShapeAcceptOperation(shape, action.operation)) {\n            return {\n              operation: assignOperationSource(action.operation, sourceWrapper),\n              context: action.context,\n            };\n          }\n        } catch {\n          // Fallback to the default case when the selector shape does not exist,\n          // which can occur for a non-existent destination.\n        }\n      }\n    }\n    return {\n      operation: this.assignExhaustive(algebraFactory, action.operation, sources),\n      // We only keep queryString in the context if we only have a single source that accepts the full operation.\n      // In that case, the queryString can be sent to the source as-is.\n      context: action.context\n        .delete(KeysInitQuery.queryString),\n    };\n  }\n\n  /**\n   * Assign the given sources to the leaves in the given query operation.\n   * Leaves will be wrapped in a union operation and duplicated for every source.\n   * The input operation will not be modified.\n   * @param algebraFactory The algebra factory.\n   * @param operation The input operation.\n   * @param sources The sources to assign.\n   */\n  public assignExhaustive(\n    algebraFactory: Factory,\n    operation: Algebra.Operation,\n    sources: IQuerySourceWrapper[],\n  ): Algebra.Operation {\n    // eslint-disable-next-line ts/no-this-alias\n    const self = this;\n    return Util.mapOperation(operation, {\n      [Algebra.types.PATTERN](subOperation, factory) {\n        if (sources.length === 1) {\n          return {\n            result: assignOperationSource(subOperation, sources[0]),\n            recurse: false,\n          };\n        }\n        return {\n          result: factory.createUnion(sources\n            .map(source => assignOperationSource(subOperation, source))),\n          recurse: false,\n        };\n      },\n      [Algebra.types.LINK](subOperation, factory) {\n        if (sources.length === 1) {\n          return {\n            result: assignOperationSource(subOperation, sources[0]),\n            recurse: false,\n          };\n        }\n        return {\n          result: factory.createAlt(sources\n            .map(source => assignOperationSource(subOperation, source))),\n          recurse: false,\n        };\n      },\n      [Algebra.types.NPS](subOperation, factory) {\n        if (sources.length === 1) {\n          return {\n            result: assignOperationSource(subOperation, sources[0]),\n            recurse: false,\n          };\n        }\n        return {\n          result: factory.createAlt(sources\n            .map(source => assignOperationSource(subOperation, source))),\n          recurse: false,\n        };\n      },\n      [Algebra.types.SERVICE](subOperation) {\n        return {\n          result: subOperation,\n          recurse: false,\n        };\n      },\n      [Algebra.types.CONSTRUCT](subOperation, factory) {\n        return {\n          result: factory.createConstruct(\n            self.assignExhaustive(algebraFactory, subOperation.input, sources),\n            subOperation.template,\n          ),\n          recurse: false,\n        };\n      },\n      [Algebra.types.DELETE_INSERT](subOperation, factory) {\n        return {\n          result: factory.createDeleteInsert(\n            subOperation.delete,\n            subOperation.insert,\n            subOperation.where ? self.assignExhaustive(algebraFactory, subOperation.where, sources) : undefined,\n          ),\n          recurse: false,\n        };\n      },\n    }, algebraFactory);\n  }\n}\n"]}
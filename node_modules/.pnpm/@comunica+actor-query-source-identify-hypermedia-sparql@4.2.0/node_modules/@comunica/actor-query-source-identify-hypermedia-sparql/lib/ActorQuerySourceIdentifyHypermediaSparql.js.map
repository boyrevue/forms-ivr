{"version":3,"file":"ActorQuerySourceIdentifyHypermediaSparql.js","sourceRoot":"","sources":["ActorQuerySourceIdentifyHypermediaSparql.ts"],"names":[],"mappings":";;;AAQA,yGAEwD;AACxD,+DAA8E;AAE9E,yCAAoD;AAEpD,6EAAmE;AACnE,qDAA0C;AAC1C,2DAAwD;AAExD;;GAEG;AACH,MAAa,wCAAyC,SAAQ,yEAAkC;IAY9F,YAAmB,IAAmD;QACpE,KAAK,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IACxB,CAAC;IAEM,KAAK,CAAC,YAAY,CACvB,MAA4C;QAE5C,IAAI,CAAC,MAAM,CAAC,eAAe,IAAI,CAAC,IAAI,CAAC,eAAe,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,aAAa;YACpF,CAAC,CAAC,IAAI,CAAC,cAAc,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC;YAChG,OAAO,IAAA,eAAQ,EAAC,SAAS,IAAI,CAAC,IAAI,0EAA0E,CAAC,CAAC;QAChH,CAAC;QACD,OAAO,IAAA,eAAQ,EAAC,EAAE,YAAY,EAAE,CAAC,EAAE,CAAC,CAAC;IACvC,CAAC;IAEM,KAAK,CAAC,GAAG,CAAC,MAA4C;QAC3D,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,OAAO,EAAE,cAAc,MAAM,CAAC,GAAG,uCAAuC,MAAM,CAAC,QAAQ,CAAC,aAAa,IAAI,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC;QAE3I,MAAM,WAAW,GAAwB,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,+BAAa,CAAC,WAAW,CAAC,CAAC;QAC3F,MAAM,cAAc,GAAG,IAAI,yBAAO,CAAC,WAAW,CAAC,CAAC;QAChD,MAAM,gBAAgB,GAAG,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,oCAAkB,CAAC,YAAY,CAAC,EAAE,MAAM,KAAK,CAAC,CAAC;QAC3F,MAAM,MAAM,GAAG,IAAI,qCAAiB,CAClC,CAAC,MAAM,CAAC,eAAe,IAAI,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,aAAa,IAAI,MAAM,CAAC,GAAG,EAC3G,MAAM,CAAC,OAAO,EACd,IAAI,CAAC,YAAY,EACjB,IAAI,CAAC,UAAU,EACf,WAAW,EACX,cAAc,EACd,MAAM,wCAAe,CAAC,MAAM,CAAC,IAAI,CAAC,4BAA4B,EAAE,MAAM,CAAC,OAAO,EAAE,WAAW,CAAC,EAC5F,IAAI,CAAC,YAAY,EACjB,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,YAAY;QACjB,0EAA0E;QAC1E,IAAI,CAAC,uBAAuB,IAAI,CAAC,gBAAgB,EACjD,IAAI,CAAC,+BAA+B,EACpC,MAAM,CAAC,QAAQ,CAAC,YAAY,EAC5B,MAAM,CAAC,QAAQ,CAAC,iBAAiB,EACjC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CACzB,CAAC;QACF,OAAO,EAAE,MAAM,EAAE,CAAC;IACpB,CAAC;CACF;AApDD,4FAoDC","sourcesContent":["import type { MediatorHttp } from '@comunica/bus-http';\nimport type { MediatorMergeBindingsContext } from '@comunica/bus-merge-bindings-context';\nimport type {\n  IActionQuerySourceIdentifyHypermedia,\n  IActorQuerySourceIdentifyHypermediaOutput,\n  IActorQuerySourceIdentifyHypermediaArgs,\n  IActorQuerySourceIdentifyHypermediaTest,\n} from '@comunica/bus-query-source-identify-hypermedia';\nimport {\n  ActorQuerySourceIdentifyHypermedia,\n} from '@comunica/bus-query-source-identify-hypermedia';\nimport { KeysInitQuery, KeysQueryOperation } from '@comunica/context-entries';\nimport type { TestResult } from '@comunica/core';\nimport { failTest, passTest } from '@comunica/core';\nimport type { ComunicaDataFactory } from '@comunica/types';\nimport { BindingsFactory } from '@comunica/utils-bindings-factory';\nimport { Factory } from 'sparqlalgebrajs';\nimport { QuerySourceSparql } from './QuerySourceSparql';\n\n/**\n * A comunica SPARQL Query Source Identify Hypermedia Actor.\n */\nexport class ActorQuerySourceIdentifyHypermediaSparql extends ActorQuerySourceIdentifyHypermedia {\n  public readonly mediatorHttp: MediatorHttp;\n  public readonly mediatorMergeBindingsContext: MediatorMergeBindingsContext;\n  public readonly checkUrlSuffix: boolean;\n  public readonly forceHttpGet: boolean;\n  public readonly cacheSize: number;\n  public readonly forceSourceType: boolean;\n  public readonly bindMethod: BindMethod;\n  public readonly countTimeout: number;\n  public readonly cardinalityCountQueries: boolean;\n  public readonly cardinalityEstimateConstruction: boolean;\n\n  public constructor(args: IActorQuerySourceIdentifyHypermediaSparqlArgs) {\n    super(args, 'sparql');\n  }\n\n  public async testMetadata(\n    action: IActionQuerySourceIdentifyHypermedia,\n  ): Promise<TestResult<IActorQuerySourceIdentifyHypermediaTest>> {\n    if (!action.forceSourceType && !this.forceSourceType && !action.metadata.sparqlService &&\n      !(this.checkUrlSuffix && (action.url.endsWith('/sparql') || action.url.endsWith('/sparql/')))) {\n      return failTest(`Actor ${this.name} could not detect a SPARQL service description or URL ending on /sparql.`);\n    }\n    return passTest({ filterFactor: 1 });\n  }\n\n  public async run(action: IActionQuerySourceIdentifyHypermedia): Promise<IActorQuerySourceIdentifyHypermediaOutput> {\n    this.logInfo(action.context, `Identified ${action.url} as sparql source with service URL: ${action.metadata.sparqlService || action.url}`);\n\n    const dataFactory: ComunicaDataFactory = action.context.getSafe(KeysInitQuery.dataFactory);\n    const algebraFactory = new Factory(dataFactory);\n    const isSingularSource = action.context.get(KeysQueryOperation.querySources)?.length === 1;\n    const source = new QuerySourceSparql(\n      (action.forceSourceType ?? this.forceSourceType) ? action.url : action.metadata.sparqlService || action.url,\n      action.context,\n      this.mediatorHttp,\n      this.bindMethod,\n      dataFactory,\n      algebraFactory,\n      await BindingsFactory.create(this.mediatorMergeBindingsContext, action.context, dataFactory),\n      this.forceHttpGet,\n      this.cacheSize,\n      this.countTimeout,\n      // Cardinalities can be infinity when we're querying just a single source.\n      this.cardinalityCountQueries && !isSingularSource,\n      this.cardinalityEstimateConstruction,\n      action.metadata.defaultGraph,\n      action.metadata.unionDefaultGraph,\n      action.metadata.datasets,\n    );\n    return { source };\n  }\n}\n\nexport interface IActorQuerySourceIdentifyHypermediaSparqlArgs extends IActorQuerySourceIdentifyHypermediaArgs {\n  /**\n   * The HTTP mediator\n   */\n  mediatorHttp: MediatorHttp;\n  /**\n   * A mediator for creating binding context merge handlers\n   */\n  mediatorMergeBindingsContext: MediatorMergeBindingsContext;\n  /**\n   * If URLs ending with '/sparql' should also be considered SPARQL endpoints.\n   * @default {true}\n   */\n  checkUrlSuffix: boolean;\n  /**\n   * If non-update queries should be sent via HTTP GET instead of POST\n   * @default {false}\n   */\n  forceHttpGet: boolean;\n  /**\n   * The cache size for COUNT queries.\n   * @range {integer}\n   * @default {1024}\n   */\n  cacheSize?: number;\n  /**\n   * If provided, forces the source type of a source.\n   * @default {false}\n   */\n  forceSourceType?: boolean;\n  /**\n   * The query operation for communicating bindings.\n   * @default {values}\n   */\n  bindMethod: BindMethod;\n  /**\n   * Timeout in ms of how long count queries are allowed to take.\n   * If the timeout is reached, an infinity cardinality is returned.\n   * @default {3000}\n   */\n  countTimeout: number;\n  /**\n   * If count queries should be sent to obtain the cardinality of (sub)queries.\n   * If set to false, resulting cardinalities will always be considered infinity.\n   * @default {true}\n   */\n  cardinalityCountQueries: boolean;\n  /**\n   * If estimates for queries should be constructed locally from sub-query cardinalities.\n   * If set to false, count queries will used for cardinality estimation at all levels.\n   * @default {false}\n   */\n  cardinalityEstimateConstruction: boolean;\n}\n\nexport type BindMethod = 'values' | 'union' | 'filter';\n"]}
{"version":3,"file":"ActorQueryOperationService.js","sourceRoot":"","sources":["ActorQueryOperationService.ts"],"names":[],"mappings":";;;AAEA,uEAAiF;AAEjF,+DAA0D;AAE1D,yCAAwD;AAOxD,6EAAmE;AACnE,6DAAmE;AACnE,2EAAyF;AAEzF,iDAAkD;AAGlD;;;GAGG;AACH,MAAa,0BAA2B,SAAQ,sDAAiD;IAK/F,YAAmB,IAAqC;QACtD,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;IACzB,CAAC;IAEM,KAAK,CAAC,aAAa,CAAC,SAA0B,EAAE,QAAwB;QAC7E,IAAI,SAAS,CAAC,IAAI,CAAC,QAAQ,KAAK,WAAW,EAAE,CAAC;YAC5C,OAAO,IAAA,eAAQ,EAAC,GAAG,IAAI,CAAC,IAAI,4CAA4C,SAAS,CAAC,IAAI,CAAC,QAAQ,aAAa,CAAC,CAAC;QAChH,CAAC;QACD,OAAO,IAAA,mBAAY,GAAE,CAAC;IACxB,CAAC;IAEM,KAAK,CAAC,YAAY,CAAC,SAA0B,EAAE,OAAuB;QAE3E,8CAA8C;QAC9C,MAAM,EAAE,WAAW,EAAE,GAAG,MAAM,IAAI,CAAC,2BAA2B,CAAC,OAAO,CAAC;YACrE,uBAAuB,EAAE;gBACvB,KAAK,EAAE,SAAS,CAAC,IAAI,CAAC,KAAK;gBAC3B,IAAI,EAAE,IAAI,CAAC,mBAAmB,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS;aACtD;YACD,OAAO;SACR,CAAC,CAAC;QAEH,kDAAkD;QAClD,IAAI,MAAqC,CAAC;QAC1C,IAAI,CAAC;YACH,MAAM,GAAG,IAAA,uCAAe,EAAC,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC;gBACjE,SAAS,EAAE,IAAA,6CAAqB,EAAC,SAAS,CAAC,KAAK,EAAE,WAAW,CAAC;gBAC9D,OAAO;aACR,CAAC,CAAC,CAAC;QACN,CAAC;QAAC,OAAO,KAAc,EAAE,CAAC;YACxB,IAAI,SAAS,CAAC,MAAM,EAAE,CAAC;gBACrB,8BAA8B;gBAC9B,MAAM,WAAW,GAAwB,OAAO,CAAC,OAAO,CAAC,+BAAa,CAAC,WAAW,CAAC,CAAC;gBACpF,MAAM,eAAe,GAAG,MAAM,wCAAe,CAAC,MAAM,CAClD,IAAI,CAAC,4BAA4B,EACjC,OAAO,EACP,WAAW,CACZ,CAAC;gBACF,MAAM,GAAG;oBACP,cAAc,EAAE,IAAI,iCAAiB,CAAe,eAAe,CAAC,QAAQ,EAAE,CAAC;oBAC/E,IAAI,EAAE,UAAU;oBAChB,QAAQ,EAAE,KAAK,IAAG,EAAE,CAAC,CAAC;wBACpB,KAAK,EAAE,IAAI,wCAAuB,EAAE;wBACpC,WAAW,EAAE,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE;wBACxC,SAAS,EAAE,EAAE;qBACd,CAAC;iBACH,CAAC;gBACF,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,sDAA+D,KAAM,CAAC,OAAO,EAAE,CAAC,CAAC;YACzG,CAAC;iBAAM,CAAC;gBACN,MAAM,KAAK,CAAC;YACd,CAAC;QACH,CAAC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AA5DD,gEA4DC","sourcesContent":["import type { MediatorMergeBindingsContext } from '@comunica/bus-merge-bindings-context';\nimport type { IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport { ActorQueryOperationTypedMediated } from '@comunica/bus-query-operation';\nimport type { MediatorQuerySourceIdentify } from '@comunica/bus-query-source-identify';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type { IActorTest, TestResult } from '@comunica/core';\nimport { failTest, passTestVoid } from '@comunica/core';\nimport type {\n  ComunicaDataFactory,\n  IActionContext,\n  IQueryOperationResult,\n  IQueryOperationResultBindings,\n} from '@comunica/types';\nimport { BindingsFactory } from '@comunica/utils-bindings-factory';\nimport { MetadataValidationState } from '@comunica/utils-metadata';\nimport { assignOperationSource, getSafeBindings } from '@comunica/utils-query-operation';\nimport type * as RDF from '@rdfjs/types';\nimport { SingletonIterator } from 'asynciterator';\nimport type { Algebra } from 'sparqlalgebrajs';\n\n/**\n * A comunica Service Query Operation Actor.\n * It unwraps the SERVICE operation and executes it on the given source.\n */\nexport class ActorQueryOperationService extends ActorQueryOperationTypedMediated<Algebra.Service> {\n  public readonly forceSparqlEndpoint: boolean;\n  public readonly mediatorMergeBindingsContext: MediatorMergeBindingsContext;\n  public readonly mediatorQuerySourceIdentify: MediatorQuerySourceIdentify;\n\n  public constructor(args: IActorQueryOperationServiceArgs) {\n    super(args, 'service');\n  }\n\n  public async testOperation(operation: Algebra.Service, _context: IActionContext): Promise<TestResult<IActorTest>> {\n    if (operation.name.termType !== 'NamedNode') {\n      return failTest(`${this.name} can only query services by IRI, while a ${operation.name.termType} was given.`);\n    }\n    return passTestVoid();\n  }\n\n  public async runOperation(operation: Algebra.Service, context: IActionContext):\n  Promise<IQueryOperationResult> {\n    // Identify the SERVICE target as query source\n    const { querySource } = await this.mediatorQuerySourceIdentify.mediate({\n      querySourceUnidentified: {\n        value: operation.name.value,\n        type: this.forceSparqlEndpoint ? 'sparql' : undefined,\n      },\n      context,\n    });\n\n    // Attach the source to the operation, and execute\n    let output: IQueryOperationResultBindings;\n    try {\n      output = getSafeBindings(await this.mediatorQueryOperation.mediate({\n        operation: assignOperationSource(operation.input, querySource),\n        context,\n      }));\n    } catch (error: unknown) {\n      if (operation.silent) {\n        // Emit a single empty binding\n        const dataFactory: ComunicaDataFactory = context.getSafe(KeysInitQuery.dataFactory);\n        const bindingsFactory = await BindingsFactory.create(\n          this.mediatorMergeBindingsContext,\n          context,\n          dataFactory,\n        );\n        output = {\n          bindingsStream: new SingletonIterator<RDF.Bindings>(bindingsFactory.bindings()),\n          type: 'bindings',\n          metadata: async() => ({\n            state: new MetadataValidationState(),\n            cardinality: { type: 'exact', value: 1 },\n            variables: [],\n          }),\n        };\n        this.logWarn(context, `An error occurred when executing a SERVICE clause: ${(<Error> error).message}`);\n      } else {\n        throw error;\n      }\n    }\n\n    return output;\n  }\n}\n\nexport interface IActorQueryOperationServiceArgs extends IActorQueryOperationTypedMediatedArgs {\n  /**\n   * If the SERVICE target should be assumed to be a SPARQL endpoint.\n   * @default {false}\n   */\n  forceSparqlEndpoint: boolean;\n  /**\n   * A mediator for creating binding context merge handlers\n   */\n  mediatorMergeBindingsContext: MediatorMergeBindingsContext;\n  /**\n   * The mediator for identifying query sources.\n   */\n  mediatorQuerySourceIdentify: MediatorQuerySourceIdentify;\n}\n"]}
{"version":3,"file":"SumAggregator.js","sourceRoot":"","sources":["SumAggregator.ts"],"names":[],"mappings":";;;AAAA,+FAA+E;AAI/E,qFAA6E;AAK7E,MAAa,aAAc,SAAQ,oDAAkB;IAGnD,YACE,SAA+B,EAC/B,QAAiB,EACA,WAAgC,EAChC,gBAA+B,EAChD,UAAoB;QAEpB,KAAK,CAAC,SAAS,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAC;QAJtB,gBAAW,GAAX,WAAW,CAAqB;QAChC,qBAAgB,GAAhB,gBAAgB,CAAe;QAN1C,UAAK,GAAyB,SAAS,CAAC;IAUhD,CAAC;IAEe,cAAc;QAC5B,OAAO,IAAA,yCAAY,EAAC,GAAG,EAAE,oCAAO,CAAC,WAAW,CAAC,CAAC;IAChD,CAAC;IAEM,OAAO,CAAC,IAAc;QAC3B,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE,CAAC;YAC7B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;QAC/C,CAAC;aAAM,CAAC;YACN,MAAM,YAAY,GAAG,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;YACrD,IAAI,CAAC,KAAK,GAAoB,IAAI,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAE,IAAI,CAAC,KAAK,EAAE,YAAY,CAAE,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;QACjH,CAAC;IACH,CAAC;IAEM,UAAU;QACf,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE,CAAC;YAC7B,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC;QAC3B,CAAC;QACD,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;IAC5C,CAAC;CACF;AAhCD,sCAgCC","sourcesContent":["import { AggregateEvaluator } from '@comunica/bus-bindings-aggregator-factory';\nimport type { ITermFunction } from '@comunica/bus-function-factory';\nimport type { ComunicaDataFactory, IExpressionEvaluator } from '@comunica/types';\nimport type { NumericLiteral } from '@comunica/utils-expression-evaluator';\nimport { typedLiteral, TypeURL } from '@comunica/utils-expression-evaluator';\nimport type * as RDF from '@rdfjs/types';\n\ntype SumState = NumericLiteral;\n\nexport class SumAggregator extends AggregateEvaluator {\n  private state: SumState | undefined = undefined;\n\n  public constructor(\n    evaluator: IExpressionEvaluator,\n    distinct: boolean,\n    private readonly dataFactory: ComunicaDataFactory,\n    private readonly additionFunction: ITermFunction,\n    throwError?: boolean,\n  ) {\n    super(evaluator, distinct, throwError);\n  }\n\n  public override emptyValueTerm(): RDF.Term {\n    return typedLiteral('0', TypeURL.XSD_INTEGER);\n  }\n\n  public putTerm(term: RDF.Term): void {\n    if (this.state === undefined) {\n      this.state = this.termToNumericOrError(term);\n    } else {\n      const internalTerm = this.termToNumericOrError(term);\n      this.state = <NumericLiteral> this.additionFunction.applyOnTerms([ this.state, internalTerm ], this.evaluator);\n    }\n  }\n\n  public termResult(): RDF.Term | undefined {\n    if (this.state === undefined) {\n      return this.emptyValue();\n    }\n    return this.state.toRDF(this.dataFactory);\n  }\n}\n"]}
{"version":3,"file":"ActorRdfMetadataExtractVoid.js","sourceRoot":"","sources":["ActorRdfMetadataExtractVoid.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  IActionRdfMetadataExtract,\n  IActorRdfMetadataExtractOutput,\n  IActorRdfMetadataExtractArgs,\n} from '@comunica/bus-rdf-metadata-extract';\nimport { ActorRdfMetadataExtract } from '@comunica/bus-rdf-metadata-extract';\nimport type { IActorTest, TestResult } from '@comunica/core';\nimport { passTestVoid } from '@comunica/core';\nimport type { IDataset, QueryResultCardinality } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { Algebra } from 'sparqlalgebrajs';\nimport {\n  RDF_TYPE,\n  SD_DEFAULT_DATASET,\n  SD_DEFAULT_GRAPH,\n  SD_FEATURE,\n  SD_GRAPH,\n  SD_UNION_DEFAULT_GRAPH,\n  VOID_CLASS,\n  VOID_CLASS_PARTITION,\n  VOID_CLASSES,\n  VOID_DATASET,\n  VOID_DISTINCT_OBJECTS,\n  VOID_DISTINCT_SUBJECTS,\n  VOID_ENTITIES,\n  VOID_PROPERTY,\n  VOID_PROPERTY_PARTITION,\n  VOID_TRIPLES,\n  VOID_URI_REGEX_PATTERN,\n  VOID_URI_SPACE,\n  VOID_VOCABULARY,\n} from './Definitions';\nimport { estimatePatternCardinality } from './Estimators';\nimport type {\n  IVoidClassPartition,\n  IVoidDataset,\n  IVoidPropertyPartition,\n} from './Types';\n\n/**\n * A comunica Void RDF Metadata Extract Actor.\n */\nexport class ActorRdfMetadataExtractVoid extends ActorRdfMetadataExtract {\n  public constructor(args: IActorRdfMetadataExtractArgs) {\n    super(args);\n  }\n\n  public async test(_action: IActionRdfMetadataExtract): Promise<TestResult<IActorTest>> {\n    return passTestVoid();\n  }\n\n  public async run(action: IActionRdfMetadataExtract): Promise<IActorRdfMetadataExtractOutput> {\n    return new Promise<IActorRdfMetadataExtractOutput>((resolve, reject) => {\n      // Track the URIs of identified datasets to extract or ignore\n      const datasetUris = new Set<string>();\n      const ignoredUris = new Set<string>();\n\n      // Track the other stats per-URI to allow arbitrary triple ordering in the stream\n      const triples: Record<string, number> = {};\n      const entities: Record<string, number> = {};\n      const vocabularies: Record<string, string[]> = {};\n      const classes: Record<string, number> = {};\n      const distinctObjects: Record<string, number> = {};\n      const distinctSubjects: Record<string, number> = {};\n      const uriRegexPatterns: Record<string, RegExp> = {};\n      const propertyPartitions: Record<string, string[]> = {};\n      const propertyPartitionProperties: Record<string, string> = {};\n      const classPartitions: Record<string, string[]> = {};\n      const classPartitionClasses: Record<string, string> = {};\n\n      // Default dataset and graph to remove in case of sd:UnionDefaultGraph\n      let defaultDatasetUri: string | undefined;\n      let defaultGraphUri: string | undefined;\n      let unionDefaultGraph = false;\n\n      action.metadata\n        .on('error', reject)\n        .on('data', (quad: RDF.Quad) => {\n          switch (quad.predicate.value) {\n            case RDF_TYPE:\n              if (quad.object.value === SD_GRAPH || quad.object.value === VOID_DATASET) {\n                datasetUris.add(quad.subject.value);\n              }\n              break;\n            case VOID_TRIPLES:\n              triples[quad.subject.value] = Number.parseInt(quad.object.value, 10);\n              break;\n            case VOID_ENTITIES:\n              entities[quad.subject.value] = Number.parseInt(quad.object.value, 10);\n              break;\n            case VOID_CLASSES:\n              classes[quad.subject.value] = Number.parseInt(quad.object.value, 10);\n              break;\n            case VOID_CLASS:\n              classPartitionClasses[quad.subject.value] = quad.object.value;\n              break;\n            case VOID_PROPERTY:\n              propertyPartitionProperties[quad.subject.value] = quad.object.value;\n              break;\n            case VOID_DISTINCT_OBJECTS:\n              distinctObjects[quad.subject.value] = Number.parseInt(quad.object.value, 10);\n              break;\n            case VOID_DISTINCT_SUBJECTS:\n              distinctSubjects[quad.subject.value] = Number.parseInt(quad.object.value, 10);\n              break;\n            case VOID_VOCABULARY:\n              if (vocabularies[quad.subject.value]) {\n                vocabularies[quad.subject.value].push(quad.object.value);\n              } else {\n                vocabularies[quad.subject.value] = [ quad.object.value ];\n              }\n              break;\n            case VOID_URI_SPACE:\n              if (!uriRegexPatterns[quad.subject.value]) {\n                uriRegexPatterns[quad.subject.value] = new RegExp(`^${quad.object.value}`, 'u');\n              }\n              break;\n            case VOID_URI_REGEX_PATTERN:\n              uriRegexPatterns[quad.subject.value] = new RegExp(quad.object.value, 'u');\n              break;\n            case VOID_PROPERTY_PARTITION:\n              ignoredUris.add(quad.object.value);\n              if (propertyPartitions[quad.subject.value]) {\n                propertyPartitions[quad.subject.value].push(quad.object.value);\n              } else {\n                propertyPartitions[quad.subject.value] = [ quad.object.value ];\n              }\n              break;\n            case VOID_CLASS_PARTITION:\n              ignoredUris.add(quad.object.value);\n              if (classPartitions[quad.subject.value]) {\n                classPartitions[quad.subject.value].push(quad.object.value);\n              } else {\n                classPartitions[quad.subject.value] = [ quad.object.value ];\n              }\n              break;\n            case SD_DEFAULT_DATASET:\n              defaultDatasetUri = quad.object.value;\n              break;\n            case SD_DEFAULT_GRAPH:\n              defaultGraphUri = quad.object.value;\n              break;\n            case SD_FEATURE:\n              if (quad.object.value === SD_UNION_DEFAULT_GRAPH) {\n                unionDefaultGraph = true;\n              }\n              break;\n          }\n        })\n        .on('end', () => {\n          const datasets: IDataset[] = [];\n\n          // Helper function to extract property partitions into a map\n          const getPropertyPartitions = (uri: string): Record<string, IVoidPropertyPartition> => {\n            const partitions: Record<string, IVoidPropertyPartition> = {};\n            for (const partitionUri of propertyPartitions[uri]) {\n              const propertyUri = propertyPartitionProperties[partitionUri];\n              if (propertyUri) {\n                partitions[propertyUri] = {\n                  distinctObjects: distinctObjects[partitionUri],\n                  distinctSubjects: distinctSubjects[partitionUri],\n                  triples: triples[partitionUri],\n                };\n              }\n            }\n            return partitions;\n          };\n\n          // Helper function to extract class partitions into a map\n          const getClassPartitions = (uri: string): Record<string, IVoidClassPartition> => {\n            const partitions: Record<string, IVoidClassPartition> = {};\n            for (const partitionUri of classPartitions[uri]) {\n              const classUri = classPartitionClasses[partitionUri];\n              if (classUri) {\n                partitions[classUri] = {\n                  entities: entities[partitionUri],\n                  propertyPartitions: propertyPartitions[partitionUri] ?\n                    getPropertyPartitions(partitionUri) :\n                    undefined,\n                };\n              }\n            }\n            return partitions;\n          };\n\n          // Always ignore intermediate default dataset\n          if (defaultDatasetUri) {\n            ignoredUris.add(defaultDatasetUri);\n          }\n\n          // Ignore default graph URI when union default graph is set\n          if (unionDefaultGraph && defaultGraphUri) {\n            ignoredUris.add(defaultGraphUri);\n          }\n\n          // Propagate vocabularies from higher level datasets to lower-level\n          if (defaultDatasetUri && defaultGraphUri && vocabularies[defaultDatasetUri]) {\n            vocabularies[defaultGraphUri] = [\n              ...vocabularies[defaultGraphUri] ?? [],\n              ...vocabularies[defaultDatasetUri],\n            ];\n          }\n\n          // Delete all the to-be-ignored datasets, such as property and class partitions\n          for (const uri of ignoredUris) {\n            datasetUris.delete(uri);\n          }\n\n          for (const uri of datasetUris) {\n            // Only the VoID descriptions with triple counts and class or property partitions are actually useful,\n            // and any other ones would contain insufficient information to use in estimation, as the formulae\n            // would go to 0 for most estimations.\n            if (triples[uri]) {\n              const dataset: IVoidDataset = {\n                entities: entities[uri],\n                identifier: uri,\n                classes: classes[uri] ?? classPartitions[uri]?.length ?? 0,\n                classPartitions: classPartitions[uri] ? getClassPartitions(uri) : undefined,\n                distinctObjects: distinctObjects[uri],\n                distinctSubjects: distinctSubjects[uri],\n                propertyPartitions: propertyPartitions[uri] ? getPropertyPartitions(uri) : undefined,\n                triples: triples[uri],\n                uriRegexPattern: uriRegexPatterns[uri],\n                vocabularies: vocabularies[uri],\n              };\n              datasets.push({\n                uri,\n                source: action.url,\n                getCardinality: (operation: Algebra.Operation): QueryResultCardinality | undefined => {\n                  if (operation.type === Algebra.types.PATTERN) {\n                    return { ...estimatePatternCardinality(dataset, operation), dataset: uri };\n                  }\n                },\n              });\n            }\n          }\n\n          resolve({ metadata: datasets.length > 0 ? { datasets } : {}});\n        });\n    });\n  }\n}\n"]}
{"version":3,"file":"Estimators.js","sourceRoot":"","sources":["Estimators.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport { RDF_TYPE } from './Definitions';\nimport type { IVoidDataset } from './Types';\n\n/**\n * Estimate triple pattern cardinality, by first applying heuristics based on void:uriPatternRegex\n * and void:vocabulary data when available, before performing estimations using the formulae.\n */\nexport function estimatePatternCardinality(\n  dataset: IVoidDataset,\n  pattern: Algebra.Pattern,\n): RDF.QueryResultCardinality {\n  const estimate: RDF.QueryResultCardinality = { type: 'exact', value: 0 };\n  if (matchPatternVocabularies(dataset, pattern) && matchPatternResourceUris(dataset, pattern)) {\n    const value = estimatePatternCardinalityRaw(dataset, pattern);\n    if (value > 0) {\n      estimate.value = value;\n      estimate.type = 'estimate';\n    }\n  }\n  return estimate;\n}\n\n/**\n * Test whether the given albegra pattern could produce answers from a dataset with the specified resourceUriPattern.\n * Specifically, if both subject and object are IRIs, but neither matches the resourceUriPattern,\n * then the dataset does not contain any RDF resources that would satisfy the pattern.\n */\nexport function matchPatternResourceUris(dataset: IVoidDataset, pattern: Algebra.Pattern): boolean {\n  return (\n    !dataset.uriRegexPattern ||\n    (pattern.subject.termType !== 'NamedNode' || dataset.uriRegexPattern.test(pattern.subject.value)) ||\n    (pattern.object.termType !== 'NamedNode' || dataset.uriRegexPattern.test(pattern.object.value))\n  );\n}\n\n/**\n * Test whether the given algebra pattern could produce answers from a dataset with the specified vocabularies.\n * Specifically, if the predicate if an IRI but it does not use any of the specifiec vocabularies,\n * then the pattern cannot be answered by the dataset.\n */\nexport function matchPatternVocabularies(dataset: IVoidDataset, pattern: Algebra.Pattern): boolean {\n  if (dataset.vocabularies !== undefined && pattern.predicate.termType === 'NamedNode') {\n    return dataset.vocabularies.some(vc => pattern.predicate.value.startsWith(vc));\n  }\n  return true;\n}\n\n/**\n * Estimate the triple pattern cardinality using the formulae from Hagedorn, Stefan, et al.\n * \"Resource Planning for SPARQL Query Execution on Data Sharing Platforms.\" COLD 1264 (2014)\n */\nexport function estimatePatternCardinalityRaw(dataset: IVoidDataset, pattern: Algebra.Pattern): number {\n  // ?s rdf:type <o> (from the original paper)\n  // ?s rdf:type _:o (also accounted for)\n  if (\n    pattern.subject.termType === 'Variable' &&\n    pattern.predicate.termType === 'NamedNode' &&\n    pattern.predicate.value === RDF_TYPE &&\n    (pattern.object.termType === 'NamedNode' || pattern.object.termType === 'BlankNode')\n  ) {\n    return getClassPartitionEntities(dataset, pattern.object);\n  }\n  // ?s ?p ?o (from the original paper)\n  if (\n    pattern.subject.termType === 'Variable' &&\n    pattern.predicate.termType === 'Variable' &&\n    pattern.object.termType === 'Variable'\n  ) {\n    return dataset.triples;\n  }\n  // <s> ?p ?o (from the original paper)\n  // _:s ?p ?o (also accounted for)\n  // <s> ?p \"o\"\n  // _:s ?p \"o\"\n  if (\n    (pattern.subject.termType === 'NamedNode' || pattern.subject.termType === 'BlankNode') &&\n    pattern.predicate.termType === 'Variable' &&\n    (pattern.object.termType === 'Variable' || pattern.object.termType === 'Literal')\n  ) {\n    const distinctSubjects = getDistinctSubjects(dataset);\n    if (distinctSubjects > 0) {\n      return dataset.triples / distinctSubjects;\n    }\n  }\n  // ?s <p> ?o (from the original paper)\n  // ?s <p> \"o\" (also accounted for)\n  if (\n    pattern.subject.termType === 'Variable' &&\n    pattern.predicate.termType === 'NamedNode' &&\n    (pattern.object.termType === 'Variable' || pattern.object.termType === 'Literal')\n  ) {\n    return getPredicateTriples(dataset, pattern.predicate);\n  }\n  // ?s ?p <o> (from the original paper)\n  // ?s ?p _:o (also accounted for)\n  // ?s ?p \"o\"\n  if (\n    pattern.subject.termType === 'Variable' &&\n    pattern.predicate.termType === 'Variable' &&\n    (\n      pattern.object.termType === 'NamedNode' ||\n      pattern.object.termType === 'BlankNode' ||\n      pattern.object.termType === 'Literal'\n    )\n  ) {\n    const distinctObjects = getDistinctObjects(dataset);\n    if (distinctObjects > 0) {\n      return dataset.triples / distinctObjects;\n    }\n  }\n  // <s> <p> ?o (from the original paper)\n  // _:s <p> ?o (also accounted for)\n  // <s> <p> \"o\"\n  // _:s <p> \"o\"\n  if (\n    (pattern.subject.termType === 'NamedNode' || pattern.subject.termType === 'BlankNode') &&\n    pattern.predicate.termType === 'NamedNode' &&\n    (pattern.object.termType === 'Variable' || pattern.object.termType === 'Literal')\n  ) {\n    const predicateTriples = getPredicateTriples(dataset, pattern.predicate);\n    const predicateSubjects = getPredicateSubjects(dataset, pattern.predicate);\n    return predicateSubjects > 0 ? predicateTriples / predicateSubjects : predicateTriples;\n  }\n  // <s> ?p <o> (from the original paper)\n  // _:s ?p _:o (also accounted for)\n  // _:s ?p <o>\n  // <s> ?p _:o\n  if (\n    (pattern.subject.termType === 'NamedNode' || pattern.subject.termType === 'BlankNode') &&\n    pattern.predicate.termType === 'Variable' &&\n    (pattern.object.termType === 'NamedNode' || pattern.object.termType === 'BlankNode')\n  ) {\n    const distinctSubjects = getDistinctSubjects(dataset);\n    const distinctObjects = getDistinctObjects(dataset);\n    if (distinctSubjects > 0 && distinctObjects > 0) {\n      return dataset.triples / (distinctSubjects * distinctObjects);\n    }\n  }\n  // ?s <p> <o> (from the original paper)\n  // ?s <p> _:o (also accounted for)\n  if (\n    pattern.subject.termType === 'Variable' &&\n    pattern.predicate.termType === 'NamedNode' &&\n    (pattern.object.termType === 'NamedNode' || pattern.object.termType === 'BlankNode')\n  ) {\n    const predicateTriples = getPredicateTriples(dataset, pattern.predicate);\n    const predicateObjects = getPredicateObjects(dataset, pattern.predicate);\n    return predicateObjects > 0 ? predicateTriples / predicateObjects : predicateTriples;\n  }\n  // <s> <p> <o> (from the original paper)\n  // _:s <p> _:o (also accounted for)\n  // <s> <p> _:o\n  // _:s <p> <o>\n  if (\n    (pattern.subject.termType === 'NamedNode' || pattern.subject.termType === 'BlankNode') &&\n    pattern.predicate.termType === 'NamedNode' &&\n    (pattern.object.termType === 'NamedNode' || pattern.object.termType === 'BlankNode')\n  ) {\n    const predicateTriples = getPredicateTriples(dataset, pattern.predicate);\n    const predicateSubjects = getPredicateSubjects(dataset, pattern.predicate);\n    const predicateObjects = getPredicateObjects(dataset, pattern.predicate);\n    return predicateSubjects > 0 && predicateObjects > 0 ?\n      predicateTriples / (predicateSubjects * predicateObjects) :\n      predicateTriples;\n  }\n\n  // In all other cases, return the total triple count as absolute upper bound\n  return dataset.triples;\n}\n\n/**\n * Attempts to retrieve void:distinctObjects, falls back to void:entities.\n * Returns the total triple count as fallback upper bound.\n */\nexport function getDistinctObjects(dataset: IVoidDataset): number {\n  return dataset.distinctObjects ?? dataset.entities ?? dataset.triples;\n}\n\n/**\n * Attempts to retrieve void:distinctSubjects, falls back to void:entities.\n * Returns the total triple count as fallback upper bound.\n */\nexport function getDistinctSubjects(dataset: IVoidDataset): number {\n  return dataset.distinctSubjects ?? dataset.entities ?? dataset.triples;\n}\n\n/**\n * Attempts to retrieve void:distinctObjects from a void:propertyPartition.\n * Returns 0 when property partitions are available but the specific property is not.\n * Falls back to total triple count as upper bound without any property partitions.\n */\nexport function getPredicateObjects(dataset: IVoidDataset, predicate: RDF.NamedNode): number {\n  if (dataset.propertyPartitions) {\n    const partition = dataset.propertyPartitions[predicate.value];\n    return partition?.distinctObjects ?? partition?.triples ?? 0;\n  }\n  return dataset.triples;\n}\n\n/**\n * Attempts to retrieve void:distinctSubjects from a void:propertyPartition.\n * Returns 0 when property partitions are available but the specific property is not.\n * Falls back to total triple count as upper bound without any property partitions.\n */\nexport function getPredicateSubjects(dataset: IVoidDataset, predicate: RDF.NamedNode): number {\n  if (dataset.propertyPartitions) {\n    const partition = dataset.propertyPartitions[predicate.value];\n    return partition?.distinctSubjects ?? partition?.triples ?? 0;\n  }\n  return dataset.triples;\n}\n\n/**\n * Attempts to retrieve void:triples from a void:propertyPartition.\n * Returns 0 when property partitions are available but the specific property is not.\n * Falls back to total triple count as upper bound without any property partitions.\n */\nexport function getPredicateTriples(dataset: IVoidDataset, predicate: RDF.NamedNode): number {\n  if (dataset.propertyPartitions) {\n    return dataset.propertyPartitions[predicate.value]?.triples ?? 0;\n  }\n  return dataset.triples;\n}\n\n/**\n * Attempts to retrieve void:entities from a void:classPartition.\n * Returns 0 when class partitions are available but the specified class is not.\n * Falls back to estimation using void:entities and void:classes on the dataset,\n * and finally total dataset triple count as upper bound.\n */\nexport function getClassPartitionEntities(dataset: IVoidDataset, object: RDF.NamedNode | RDF.BlankNode): number {\n  if (dataset.classPartitions) {\n    return dataset.classPartitions[object.value]?.entities ?? 0;\n  }\n  if (dataset.entities !== undefined && dataset.classes) {\n    return dataset.entities / dataset.classes;\n  }\n  return dataset.triples;\n}\n"]}
{"version":3,"file":"Helpers.js","sourceRoot":"","sources":["Helpers.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * These helpers provide a (albeit inflexible) DSL for writing function\n * definitions for the SPARQL functions.\n */\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type {\n  ComunicaDataFactory,\n  IDateTimeRepresentation,\n  IInternalEvaluator,\n  ImplementationFunction,\n  ImplementationFunctionTuple,\n  TermExpression,\n  VariableExpression,\n} from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { ISerializable, Literal, Quad } from '../expressions';\nimport * as E from '../expressions';\nimport { NonLexicalLiteral } from '../expressions';\nimport * as C from '../util/Consts';\nimport { TypeURL } from '../util/Consts';\nimport * as Err from '../util/Errors';\nimport type {\n  ArgumentType,\n} from './OverloadTree';\nimport { OverloadTree } from './OverloadTree';\n\ntype Term = TermExpression;\n\nexport function declare(identifier: string): Builder {\n  return new Builder(identifier);\n}\n\nexport class Builder {\n  private readonly overloadTree: OverloadTree;\n  private collected: boolean;\n\n  public constructor(identifier: string) {\n    this.overloadTree = new OverloadTree(identifier);\n    this.collected = false;\n  }\n\n  public collect(): OverloadTree {\n    if (this.collected) {\n      // Only 1 time allowed because we can't copy a tree. (And we don't need this).\n      throw new Error('Builders can only be collected once!');\n    }\n    this.collected = true;\n    return this.overloadTree;\n  }\n\n  private static wrapInvalidLexicalProtected(func: ImplementationFunction): ImplementationFunction {\n    return (expressionEvaluator: IInternalEvaluator) => (args: TermExpression[]) => {\n      for (const [ index, arg ] of args.entries()) {\n        if (arg instanceof NonLexicalLiteral) {\n          throw new Err.InvalidLexicalForm(\n            args[index].toRDF(expressionEvaluator.context.getSafe(KeysInitQuery.dataFactory)),\n          );\n        }\n      }\n      return func(expressionEvaluator)(args);\n    };\n  }\n\n  public set(\n    argTypes: [],\n    func: ImplementationFunctionTuple<[]>,\n    addInvalidHandling?: boolean,\n  ): Builder;\n  public set<T1 extends TermExpression>(\n    argTypes: [ArgumentType],\n    func: ImplementationFunctionTuple<[T1]>,\n    addInvalidHandling?: boolean,\n  ): Builder;\n  public set<T1 extends TermExpression, T2 extends TermExpression>(\n    argTypes: [ArgumentType, ArgumentType],\n    func: ImplementationFunctionTuple<[T1, T2]>,\n    addInvalidHandling?: boolean,\n  ): Builder;\n  public set<T1 extends TermExpression, T2 extends TermExpression, T3 extends TermExpression>(\n    argTypes: [ArgumentType, ArgumentType, ArgumentType],\n    func: ImplementationFunctionTuple<[T1, T2, T3]>,\n    addInvalidHandling?: boolean,\n  ): Builder;\n  public set<\n    T1 extends TermExpression,\n    T2 extends TermExpression,\n    T3 extends TermExpression,\n    T4 extends TermExpression,\n  >(\n    argTypes: [ArgumentType, ArgumentType, ArgumentType, ArgumentType],\n    func: ImplementationFunctionTuple<[T1, T2, T3, T4]>,\n    addInvalidHandling?: boolean,\n  ): Builder;\n  public set(argTypes: ArgumentType[], func: ImplementationFunction, addInvalidHandling?: boolean): Builder;\n  public set(argTypes: ArgumentType[], func: ImplementationFunction, addInvalidHandling = true): Builder {\n    this.overloadTree.addOverload(argTypes, addInvalidHandling ? Builder.wrapInvalidLexicalProtected(func) : func);\n    return this;\n  }\n\n  public copy({ from, to }: { from: ArgumentType[]; to: ArgumentType[] }): Builder {\n    const impl = this.overloadTree.getImplementationExact(from);\n    if (!impl) {\n      throw new Err.UnexpectedError(\n        'Tried to copy implementation, but types not found',\n        { from, to },\n      );\n    }\n    return this.set(to, impl);\n  }\n\n  public onUnary<T extends Term>(type: ArgumentType, op: (expressionEvaluator: IInternalEvaluator) =>\n  (val: T) => Term, addInvalidHandling = true): Builder {\n    return this.set([ type ], expressionEvaluator =>\n      ([ val ]: [T]) => op(expressionEvaluator)(val), addInvalidHandling);\n  }\n\n  public onUnaryTyped<T extends ISerializable>(\n    type: ArgumentType,\n    op: (expressionEvaluator: IInternalEvaluator) => (val: T) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set([ type ], expressionEvaluator => ([ val ]: [E.Literal<T>]) =>\n      op(expressionEvaluator)(val.typedValue), addInvalidHandling);\n  }\n\n  public onBinary<L extends Term, R extends Term>(\n    types: [ArgumentType, ArgumentType],\n    op: (expressionEvaluator: IInternalEvaluator) => (left: L, right: R) => Term,\naddInvalidHandling = true,\n  ):\n    Builder {\n    return this.set(types, expressionEvaluator =>\n      ([ left, right ]: [L, R]) => op(expressionEvaluator)(left, right), addInvalidHandling);\n  }\n\n  public onBinaryTyped<L extends ISerializable, R extends ISerializable>(\n    types: [ArgumentType, ArgumentType],\n    op: (expressionEvaluator: IInternalEvaluator) => (left: L, right: R) => Term,\naddInvalidHandling = true,\n  ):\n    Builder {\n    return this.set(\n      types,\n      expressionEvaluator =>\n        ([ left, right ]: [E.Literal<L>, E.Literal<R>]) => op(expressionEvaluator)(left.typedValue, right.typedValue),\n      addInvalidHandling,\n    );\n  }\n\n  public onTernaryTyped<A1 extends ISerializable, A2 extends ISerializable, A3 extends ISerializable>(\n    types: [ArgumentType, ArgumentType, ArgumentType],\n    op: (expressionEvaluator: IInternalEvaluator)\n    => (a1: A1, a2: A2, a3: A3) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(types, expressionEvaluator => ([ a1, a2, a3 ]: [E.Literal<A1>, E.Literal<A2>, E.Literal<A3>]) =>\n      op(expressionEvaluator)(a1.typedValue, a2.typedValue, a3.typedValue), addInvalidHandling);\n  }\n\n  public onTernary<A1 extends Term, A2 extends Term, A3 extends Term>(\n    types: [ArgumentType, ArgumentType, ArgumentType],\n    op: (expressionEvaluator: IInternalEvaluator) =>\n    (a1: A1, a2: A2, a3: A3) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(types, expressionEvaluator =>\n      ([ a1, a2, a3 ]: [A1, A2, A3]) => op(expressionEvaluator)(a1, a2, a3), addInvalidHandling);\n  }\n\n  public onQuaternaryTyped<\n    A1 extends ISerializable,\nA2 extends ISerializable,\nA3 extends ISerializable,\nA4 extends ISerializable,\n>(\n    types: [ArgumentType, ArgumentType, ArgumentType, ArgumentType],\n    op: (expressionEvaluator: IInternalEvaluator) => (a1: A1, a2: A2, a3: A3, a4: A4) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(types, expressionEvaluator =>\n      ([ a1, a2, a3, a4 ]: [E.Literal<A1>, E.Literal<A2>, E.Literal<A3>, E.Literal<A4>]) =>\n        op(expressionEvaluator)(a1.typedValue, a2.typedValue, a3.typedValue, a4.typedValue), addInvalidHandling);\n  }\n\n  public onTerm1<T extends Term>(\n    op: (expressionEvaluator: IInternalEvaluator) =>\n    (term: T) => Term,\naddInvalidHandling = false,\n  ): Builder {\n    return this.set(\n      [ 'term' ],\n      expressionEvaluator => ([ term ]: [T]) => op(expressionEvaluator)(term),\n      addInvalidHandling,\n    );\n  }\n\n  public onTerm3(op: (expressionEvaluator: IInternalEvaluator) => (t1: Term, t2: Term, t3: Term) => Term):\n  Builder {\n    return this.set(\n      [ 'term', 'term', 'term' ],\n      expressionEvaluator => ([ t1, t2, t3 ]: [Term, Term, Term]) => op(expressionEvaluator)(t1, t2, t3),\n    );\n  }\n\n  public onQuad1(op: (expressionEvaluator: IInternalEvaluator) => (term: Term & Quad) => Term): Builder {\n    return this.set([ 'quad' ], expressionEvaluator => ([ term ]: [Term & Quad]) => op(expressionEvaluator)(term));\n  }\n\n  public onLiteral1<T extends ISerializable>(\n    op: (expressionEvaluator: IInternalEvaluator) =>\n    (lit: E.Literal<T>) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(\n      [ 'literal' ],\n      expressionEvaluator => ([ term ]: [E.Literal<T>]) => op(expressionEvaluator)(term),\n      addInvalidHandling,\n    );\n  }\n\n  public onBoolean1(\n    op: (expressionEvaluator: IInternalEvaluator) => (lit: E.BooleanLiteral) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(\n      [ C.TypeURL.XSD_BOOLEAN ],\n      expressionEvaluator => ([ lit ]: [E.BooleanLiteral]) => op(expressionEvaluator)(lit),\n      addInvalidHandling,\n    );\n  }\n\n  public onBoolean1Typed(\n    op: (expressionEvaluator: IInternalEvaluator) => (lit: boolean) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(\n      [ C.TypeURL.XSD_BOOLEAN ],\n      expressionEvaluator => ([ lit ]: [E.BooleanLiteral]) => op(expressionEvaluator)(lit.typedValue),\n      addInvalidHandling,\n    );\n  }\n\n  public onString1(\n    op: (expressionEvaluator: IInternalEvaluator) => (lit: E.Literal<string>) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(\n      [ C.TypeURL.XSD_STRING ],\n      expressionEvaluator => ([ lit ]: [E.Literal<string>]) => op(expressionEvaluator)(lit),\n      addInvalidHandling,\n    );\n  }\n\n  public onString1Typed(\n    op: (expressionEvaluator: IInternalEvaluator) => (lit: string) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(\n      [ C.TypeURL.XSD_STRING ],\n      expressionEvaluator => ([ lit ]: [E.Literal<string>]) => op(expressionEvaluator)(lit.typedValue),\n      addInvalidHandling,\n    );\n  }\n\n  public onLangString1(\n    op: (expressionEvaluator: IInternalEvaluator) => (lit: E.LangStringLiteral) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(\n      [ C.TypeURL.RDF_LANG_STRING ],\n      expressionEvaluator => ([ lit ]: [E.LangStringLiteral]) => op(expressionEvaluator)(lit),\n      addInvalidHandling,\n    );\n  }\n\n  public onStringly1(\n    op: (expressionEvaluator: IInternalEvaluator) => (lit: E.Literal<string>) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(\n      [ C.TypeAlias.SPARQL_STRINGLY ],\n      expressionEvaluator => ([ lit ]: [E.Literal<string>]) => op(expressionEvaluator)(lit),\n      addInvalidHandling,\n    );\n  }\n\n  public onStringly1Typed(\n    op: (expressionEvaluator: IInternalEvaluator) => (lit: string) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(\n      [ C.TypeAlias.SPARQL_STRINGLY ],\n      expressionEvaluator => ([ lit ]: [E.Literal<string>]) => op(expressionEvaluator)(lit.typedValue),\n      addInvalidHandling,\n    );\n  }\n\n  public onNumeric1(\n    op: (expressionEvaluator: IInternalEvaluator) => (val: E.NumericLiteral) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(\n      [ C.TypeAlias.SPARQL_NUMERIC ],\n      expressionEvaluator => ([ val ]: [E.NumericLiteral]) => op(expressionEvaluator)(val),\n      addInvalidHandling,\n    );\n  }\n\n  public onDateTime1(\n    op: (expressionEvaluator: IInternalEvaluator) => (date: E.DateTimeLiteral) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this\n      .set(\n        [ C.TypeURL.XSD_DATE_TIME ],\n        expressionEvaluator => ([ val ]: [E.DateTimeLiteral]) => op(expressionEvaluator)(val),\n        addInvalidHandling,\n      );\n  }\n\n  /**\n   * We return the base types and not the provided types because we don't want to create invalid terms.\n   * Providing negative number to a function unary - for example should not\n   * return a term of type negative number having a positive value.\n   * @param op the numeric operator performed\n   * @param addInvalidHandling whether to add invalid handling,\n   *   whether to add @param op in @see wrapInvalidLexicalProtected\n   */\n  public numericConverter(\n    op: (expressionEvaluator: IInternalEvaluator) => (val: number) => number,\naddInvalidHandling = true,\n  ): Builder {\n    const evalHelper = (expressionEvaluator: IInternalEvaluator) => (arg: Term): number =>\n      op(expressionEvaluator)((<Literal<number>>arg).typedValue);\n    return this.onUnary(TypeURL.XSD_INTEGER, expressionEvaluator => arg =>\n      integer(evalHelper(expressionEvaluator)(arg)), addInvalidHandling)\n      .onUnary(TypeURL.XSD_DECIMAL, expressionEvaluator => arg =>\n        decimal(evalHelper(expressionEvaluator)(arg)), addInvalidHandling)\n      .onUnary(TypeURL.XSD_FLOAT, expressionEvaluator => arg =>\n        float(evalHelper(expressionEvaluator)(arg)), addInvalidHandling)\n      .onUnary(TypeURL.XSD_DOUBLE, expressionEvaluator => arg =>\n        double(evalHelper(expressionEvaluator)(arg)), addInvalidHandling);\n  }\n\n  /**\n   * !!! Be aware when using this function, it will create different overloads with different return types !!!\n   * Arithmetic operators take 2 numeric arguments, and return a single numerical\n   * value. The type of the return value is heavily dependent on the types of the\n   * input arguments. In JS everything is a double, but in SPARQL it is not.\n   *\n   * The different arguments are handled by type promotion and subtype substitution.\n   * The way numeric function arguments work is described here:\n   * https://www.w3.org/TR/xpath20/#mapping\n   * Above url is referenced in the sparql spec: https://www.w3.org/TR/sparql11-query/#OperatorMapping\n   */\n  public arithmetic(\n    op: (expressionEvaluator: IInternalEvaluator) => (left: number, right: number) => number,\naddInvalidHandling = true,\n  ): Builder {\n    const evalHelper = (expressionEvaluator: IInternalEvaluator) => (left: Term, right: Term): number =>\n      op(expressionEvaluator)((<Literal<number>>left).typedValue, (<Literal<number>>right).typedValue);\n    return this.onBinary([ TypeURL.XSD_INTEGER, TypeURL.XSD_INTEGER ], expressionEvaluator => (left, right) =>\n      integer(evalHelper(expressionEvaluator)(left, right)), addInvalidHandling)\n      .onBinary([ TypeURL.XSD_DECIMAL, TypeURL.XSD_DECIMAL ], expressionEvaluator => (left, right) =>\n        decimal(evalHelper(expressionEvaluator)(left, right)), addInvalidHandling)\n      .onBinary([ TypeURL.XSD_FLOAT, TypeURL.XSD_FLOAT ], expressionEvaluator => (left, right) =>\n        float(evalHelper(expressionEvaluator)(left, right)), addInvalidHandling)\n      .onBinary([ TypeURL.XSD_DOUBLE, TypeURL.XSD_DOUBLE ], expressionEvaluator => (left, right) =>\n        double(evalHelper(expressionEvaluator)(left, right)), addInvalidHandling);\n  }\n\n  public numberTest(\n    test: (expressionEvaluator: IInternalEvaluator) => (left: number, right: number) => boolean,\n  ): Builder {\n    return this.numeric(expressionEvaluator => ([ left, right ]: E.NumericLiteral[]) => {\n      const result = test(expressionEvaluator)(left.typedValue, right.typedValue);\n      return bool(result);\n    });\n  }\n\n  public stringTest(\n    test: (expressionEvaluator: IInternalEvaluator) => (left: string, right: string) => boolean,\naddInvalidHandling = true,\n  ): Builder {\n    return this\n      .set(\n        [ C.TypeURL.XSD_STRING, C.TypeURL.XSD_STRING ],\n        expressionEvaluator => ([ left, right ]: E.StringLiteral[]) => {\n          const result = test(expressionEvaluator)(left.typedValue, right.typedValue);\n          return bool(result);\n        },\n        addInvalidHandling,\n      );\n  }\n\n  public booleanTest(\n    test: (expressionEvaluator: IInternalEvaluator) => (left: boolean, right: boolean) => boolean,\naddInvalidHandling = true,\n  ): Builder {\n    return this\n      .set(\n        [ C.TypeURL.XSD_BOOLEAN, C.TypeURL.XSD_BOOLEAN ],\n        expressionEvaluator => ([ left, right ]: E.BooleanLiteral[]) => {\n          const result = test(expressionEvaluator)(left.typedValue, right.typedValue);\n          return bool(result);\n        },\n        addInvalidHandling,\n      );\n  }\n\n  public dateTimeTest(test: (expressionEvaluator: IInternalEvaluator)\n  => (left: IDateTimeRepresentation, right: IDateTimeRepresentation) => boolean, addInvalidHandling = true): Builder {\n    return this\n      .set(\n        [ C.TypeURL.XSD_DATE_TIME, C.TypeURL.XSD_DATE_TIME ],\n        expressionEvaluator => ([ left, right ]: E.DateTimeLiteral[]) => {\n          const result = test(expressionEvaluator)(left.typedValue, right.typedValue);\n          return bool(result);\n        },\n        addInvalidHandling,\n      );\n  }\n\n  public numeric<T extends TermExpression>(op: ImplementationFunctionTuple<[T, T]>): Builder {\n    return this.set([ C.TypeAlias.SPARQL_NUMERIC, C.TypeAlias.SPARQL_NUMERIC ], op);\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Literal Construction helpers\n// ----------------------------------------------------------------------------\n\nexport function bool(val: boolean): E.BooleanLiteral {\n  return new E.BooleanLiteral(val);\n}\n\nexport function integer(num: number): E.IntegerLiteral {\n  return new E.IntegerLiteral(num);\n}\n\nexport function decimal(num: number): E.DecimalLiteral {\n  return new E.DecimalLiteral(num);\n}\n\nexport function float(num: number): E.FloatLiteral {\n  return new E.FloatLiteral(num);\n}\n\nexport function double(num: number): E.DoubleLiteral {\n  return new E.DoubleLiteral(num);\n}\n\nexport function string(str: string): E.StringLiteral {\n  return new E.StringLiteral(str);\n}\n\nexport function langString(str: string, lang: string): E.LangStringLiteral {\n  return new E.LangStringLiteral(str, lang);\n}\n\nexport function dateTime(date: IDateTimeRepresentation, str: string): E.DateTimeLiteral {\n  return new E.DateTimeLiteral(date, str);\n}\n\nexport function expressionToVar(\n  dataFactory: ComunicaDataFactory,\n  variableExpression: VariableExpression,\n): RDF.Variable {\n  return dataFactory.variable(variableExpression.name.slice(1));\n}\n"]}
{"version":3,"file":"GroupsState.js","sourceRoot":"","sources":["GroupsState.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IBindingsAggregator, MediatorBindingsAggregatorFactory } from '@comunica/bus-bindings-aggregator-factory';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type { Bindings, ComunicaDataFactory, IActionContext } from '@comunica/types';\nimport type { BindingsFactory } from '@comunica/utils-bindings-factory';\nimport { bindingsToCompactString } from '@comunica/utils-bindings-factory';\nimport type * as RDF from '@rdfjs/types';\nimport type { Algebra } from 'sparqlalgebrajs';\n\n/**\n * A simple type alias for strings that should be hashes of Bindings\n */\nexport type BindingsHash = string;\n\n/**\n * A state container for a single group\n *\n * @property {Bindings} bindings - The binding entries on which we group\n */\nexport interface IGroup {\n  bindings: Bindings;\n  aggregators: Record<string, IBindingsAggregator>;\n}\n\n/**\n * A state manager for the groups constructed by consuming the bindings-stream.\n */\nexport class GroupsState {\n  private readonly groups: Map<BindingsHash, IGroup>;\n  // We need to the promises of a group so we can await the initialisation/ creation of them.\n  //  Without this we could have duplicate work/ override precious work.\n  private readonly groupsInitializer: Map<BindingsHash, Promise<IGroup>>;\n  private readonly groupVariables: Set<string>;\n  private readonly distinctHashes: null | Map<BindingsHash, Set<BindingsHash>>;\n  private waitCounter: number;\n  // Function that resolves the promise given by collectResults\n  private waitResolver: (bindings: Bindings[]) => void;\n  private resultHasBeenCalled: boolean;\n\n  public constructor(\n    private readonly pattern: Algebra.Group,\n    private readonly mediatorBindingsAggregatorFactory: MediatorBindingsAggregatorFactory,\n    private readonly context: IActionContext,\n    private readonly bindingsFactory: BindingsFactory,\n    private readonly variables: RDF.Variable[],\n  ) {\n    this.groups = new Map();\n    this.groupsInitializer = new Map();\n    this.groupVariables = new Set(this.pattern.variables.map(x => x.value));\n    this.waitCounter = 1;\n    this.resultHasBeenCalled = false;\n  }\n\n  /**\n   * - Consumes a stream binding\n   * - Find the corresponding group and create one if need be\n   * - Feeds the binding to the group's aggregators\n   *\n   * @param {Bindings} bindings - The Bindings to consume\n   */\n  public consumeBindings(bindings: Bindings): Promise<void> {\n    const check = this.resultCheck<void>();\n    if (check) {\n      return check;\n    }\n    // We increment the counter and decrement him when put action is performed.\n    this.waitCounter++;\n\n    // Select the bindings on which we group\n    const grouper = bindings\n      .filter((_, variable) => this.groupVariables.has(variable.value));\n    const groupHash = this.hashBindings(grouper);\n\n    // First member of group -> create new group\n    let groupInitializer: Promise<IGroup> | undefined = this.groupsInitializer.get(groupHash);\n\n    let res: Promise<any>;\n    if (groupInitializer) {\n      const groupInitializerDefined = groupInitializer;\n      res = (async() => {\n        const group = await groupInitializerDefined;\n        await Promise.all(this.pattern.aggregates.map(async(aggregate) => {\n          // Distinct handling is done in the aggregator.\n          const variable = aggregate.variable.value;\n          await group.aggregators[variable].putBindings(bindings);\n        }));\n      })().then(async() => {\n        await this.subtractWaitCounterAndCollect();\n      });\n    } else {\n      // Initialize state for all aggregators for new group\n      groupInitializer = (async() => {\n        const aggregators: Record<string, IBindingsAggregator> = {};\n        await Promise.all(this.pattern.aggregates.map(async(aggregate) => {\n          const key = aggregate.variable.value;\n          aggregators[key] = await this.mediatorBindingsAggregatorFactory\n            .mediate({ expr: aggregate, context: this.context });\n          await aggregators[key].putBindings(bindings);\n        }));\n\n        const group = { aggregators, bindings: grouper };\n        this.groups.set(groupHash, group);\n        await this.subtractWaitCounterAndCollect();\n        return group;\n      })();\n      this.groupsInitializer.set(groupHash, groupInitializer);\n      res = groupInitializer;\n    }\n    return res;\n  }\n\n  private async subtractWaitCounterAndCollect(): Promise<void> {\n    if (--this.waitCounter === 0) {\n      await this.handleResultCollection();\n    }\n  }\n\n  private async handleResultCollection(): Promise<void> {\n    const dataFactory: ComunicaDataFactory = this.context.getSafe(KeysInitQuery.dataFactory);\n    // Collect groups\n    let rows: Bindings[] = await Promise.all([ ...this.groups ].map(async([ _, group ]) => {\n      const { bindings: groupBindings, aggregators } = group;\n\n      // Collect aggregator bindings\n      // If the aggregate errorred, the result will be undefined\n      let returnBindings = groupBindings;\n      for (const variable in aggregators) {\n        const value = await aggregators[variable].result();\n        if (value) {\n          // Filter undefined\n          returnBindings = returnBindings.set(dataFactory.variable(variable), value);\n        }\n      }\n\n      // Merge grouping bindings and aggregator bindings\n      return returnBindings;\n    }));\n\n    // Case: No Input\n    // Some aggregators still define an output on the empty input\n    // Result is a single Bindings\n    if (rows.length === 0 && this.groupVariables.size === 0) {\n      const single: [RDF.Variable, RDF.Term][] = [];\n      await Promise.all(this.pattern.aggregates.map(async(aggregate) => {\n        const key = aggregate.variable;\n        const aggregator = await this.mediatorBindingsAggregatorFactory\n          .mediate({ expr: aggregate, context: this.context });\n        const value = await aggregator.result();\n        if (value !== undefined) {\n          single.push([ key, value ]);\n        }\n      }));\n      rows = [ this.bindingsFactory.bindings(single) ];\n    }\n\n    this.waitResolver(rows);\n  }\n\n  private resultCheck<T>(): Promise<T> | undefined {\n    if (this.resultHasBeenCalled) {\n      return Promise.reject(new Error('Calling any function after calling collectResult is invalid.'));\n    }\n  }\n\n  /**\n   * Collect the result of the final state. This returns a Bindings per group,\n   * and a (possibly empty) Bindings in case no Bindings have been consumed yet.\n   * You can only call this method once, after calling this method,\n   * calling any function on this will result in an error being thrown.\n   */\n  public async collectResults(): Promise<Bindings[]> {\n    const check = this.resultCheck<Bindings[]>();\n    if (check) {\n      return check;\n    }\n    this.resultHasBeenCalled = true;\n    const res = new Promise<Bindings[]>((resolve) => {\n      this.waitResolver = resolve;\n    });\n    await this.subtractWaitCounterAndCollect();\n    return res;\n  }\n\n  /**\n   * @param {Bindings} bindings - Bindings to hash\n   */\n  private hashBindings(bindings: Bindings): BindingsHash {\n    return bindingsToCompactString(bindings, this.variables);\n  }\n}\n"]}
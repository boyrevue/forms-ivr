{"version":3,"file":"ActorFunctionFactoryExpressionExtensions.js","sourceRoot":"","sources":["ActorFunctionFactoryExpressionExtensions.ts"],"names":[],"mappings":";;;AAMA,yEAEwC;AACxC,+DAAmF;AAEnF,yCAAwD;AAGxD,uDAA+C;AAC/C,qDAAkD;AAElD;;GAEG;AACH,MAAa,wCAAyC,SAAQ,2CAAoB;IAChF,YAAmB,IAA+B;QAChD,KAAK,CAAC,IAAI,CAAC,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,YAAY,EAA0B;QACjE,MAAM,eAAe,GACnB,OAAO,CAAC,OAAO,CAAC,yCAAuB,CAAC,wBAAwB,CAAC,CAAC;QACpE,MAAM,UAAU,GAAG,MAAM,eAAe,CAAC,IAAI,8BAAW,EAAY,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC;QAC9F,IAAI,UAAU,EAAE,CAAC;YACf,OAAO,IAAA,mBAAY,GAAE,CAAC;QACxB,CAAC;QACD,OAAO,IAAA,eAAQ,EACb,SAAS,IAAI,CAAC,IAAI,qHAAqH,+BAAa,CAAC,wBAAwB,CAAC,IAAI,OAAO,+BAAa,CAAC,kBAAkB,CAAC,IAAI,EAAE,CACjO,CAAC;IACJ,CAAC;IAEM,KAAK,CAAC,GAAG,CAAmC,EAAE,OAAO,EAAE,YAAY,EAAK;QAE7E,MAAM,eAAe,GACnB,OAAO,CAAC,OAAO,CAAC,yCAAuB,CAAC,wBAAwB,CAAC,CAAC;QACpE,MAAM,UAAU,GAAG,MAAM,eAAe,CAAC,IAAI,8BAAW,EAAY,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC;QAC9F,OACwC,IAAI,+BAAc,CAAC;YACvD,QAAQ,EAAE,YAAY;YACtB,kBAAkB,EAAE,UAAW;SAChC,CAAC,CAAC;IACP,CAAC;CACF;AA5BD,4FA4BC","sourcesContent":["import type {\n  IActionFunctionFactory,\n  IActorFunctionFactoryOutput,\n  IActorFunctionFactoryArgs,\n  IActorFunctionFactoryOutputTerm,\n} from '@comunica/bus-function-factory';\nimport {\n  ActorFunctionFactory,\n} from '@comunica/bus-function-factory';\nimport { KeysExpressionEvaluator, KeysInitQuery } from '@comunica/context-entries';\nimport type { IActorTest, TestResult } from '@comunica/core';\nimport { failTest, passTestVoid } from '@comunica/core';\nimport type { AsyncExtensionFunctionCreator } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { DataFactory } from 'rdf-data-factory';\nimport { NamedExtension } from './NamedExtension';\n\n/**\n * A comunica Expression Function Extensions Function Factory Actor.\n */\nexport class ActorFunctionFactoryExpressionExtensions extends ActorFunctionFactory {\n  public constructor(args: IActorFunctionFactoryArgs) {\n    super(args);\n  }\n\n  public async test({ context, functionName }: IActionFunctionFactory): Promise<TestResult<IActorTest>> {\n    const extensionFinder: AsyncExtensionFunctionCreator =\n      context.getSafe(KeysExpressionEvaluator.extensionFunctionCreator);\n    const definition = await extensionFinder(new DataFactory<RDF.Quad>().namedNode(functionName));\n    if (definition) {\n      return passTestVoid();\n    }\n    return failTest(\n      `Actor ${this.name} can only provide non-termExpression implementations for functions that are provided through config entries like: ${KeysInitQuery.extensionFunctionCreator.name} or ${KeysInitQuery.extensionFunctions.name}`,\n    );\n  }\n\n  public async run<T extends IActionFunctionFactory>({ context, functionName }: T):\n  Promise<T extends { requireTermExpression: true } ? IActorFunctionFactoryOutputTerm : IActorFunctionFactoryOutput> {\n    const extensionFinder: AsyncExtensionFunctionCreator =\n      context.getSafe(KeysExpressionEvaluator.extensionFunctionCreator);\n    const definition = await extensionFinder(new DataFactory<RDF.Quad>().namedNode(functionName));\n    return <T extends { requireTermExpression: true } ? IActorFunctionFactoryOutputTerm :\n      IActorFunctionFactoryOutput><unknown> new NamedExtension({\n        operator: functionName,\n        functionDefinition: definition!,\n      });\n  }\n}\n"]}
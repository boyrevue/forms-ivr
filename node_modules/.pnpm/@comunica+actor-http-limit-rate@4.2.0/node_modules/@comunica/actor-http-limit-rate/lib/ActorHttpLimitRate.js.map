{"version":3,"file":"ActorHttpLimitRate.js","sourceRoot":"","sources":["ActorHttpLimitRate.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IActionHttp, IActorHttpOutput, IActorHttpArgs, MediatorHttp } from '@comunica/bus-http';\nimport { ActorHttp } from '@comunica/bus-http';\nimport type { ActorHttpInvalidateListenable, IActionHttpInvalidate } from '@comunica/bus-http-invalidate';\nimport type { TestResult } from '@comunica/core';\nimport { ActionContextKey, failTest, passTest } from '@comunica/core';\nimport type { IMediatorTypeTime } from '@comunica/mediatortype-time';\n\nexport class ActorHttpLimitRate extends ActorHttp {\n  private readonly hostData: Map<string, IHostData>;\n  private readonly correctionMultiplier: number;\n  private readonly failureMultiplier: number;\n  private readonly limitByDefault: boolean;\n  private readonly allowOverlap: boolean;\n  private readonly httpInvalidator: ActorHttpInvalidateListenable;\n  private readonly mediatorHttp: MediatorHttp;\n\n  // Context key to indicate that the actor has already wrapped the given request\n  private static readonly keyWrapped = new ActionContextKey<boolean>('urn:comunica:actor-http-limit-rate#wrapped');\n\n  public constructor(args: IActorHttpLimitRateArgs) {\n    super(args);\n    this.mediatorHttp = args.mediatorHttp;\n    this.httpInvalidator = args.httpInvalidator;\n    this.httpInvalidator.addInvalidateListener(action => this.handleHttpInvalidateEvent(action));\n    this.correctionMultiplier = args.correctionMultiplier;\n    this.failureMultiplier = args.failureMultiplier;\n    this.limitByDefault = args.limitByDefault;\n    this.allowOverlap = args.allowOverlap;\n    this.hostData = new Map();\n  }\n\n  public async test(action: IActionHttp): Promise<TestResult<IMediatorTypeTime>> {\n    if (action.context.has(ActorHttpLimitRate.keyWrapped)) {\n      return failTest(`${this.name} can only wrap a request once`);\n    }\n    return passTest({ time: 0 });\n  }\n\n  public async run(action: IActionHttp): Promise<IActorHttpOutput> {\n    const requestUrl = ActorHttp.getInputUrl(action.input);\n    let requestHostData = this.hostData.get(requestUrl.host);\n\n    if (!requestHostData) {\n      requestHostData = {\n        latestRequestTimestamp: 0,\n        rateLimited: this.limitByDefault,\n        requestInterval: Number.NEGATIVE_INFINITY,\n      };\n      this.hostData.set(requestUrl.host, requestHostData);\n    }\n\n    const currentTimestamp = Date.now();\n    let currentRequestDelay = 0;\n\n    if (requestHostData.rateLimited) {\n      currentRequestDelay = Math.max(\n        0,\n        requestHostData.latestRequestTimestamp + requestHostData.requestInterval - currentTimestamp,\n      );\n    }\n\n    // Update the latest request timestamp before waiting, so that further requests will be delayed correctly.\n    // When overlap is disallowed, the timestamp is set to the expected despatch time of the current request,\n    // which will help smooth out request bursts by spacing them out evently. With overlap allowed, however,\n    // the timestamp is set to current time, which will result in overlapping requests and prevent smoothing.\n    requestHostData.latestRequestTimestamp = currentTimestamp + (this.allowOverlap ? 0 : 1) * currentRequestDelay;\n\n    if (currentRequestDelay > 0) {\n      this.logDebug(action.context, 'Delaying request', () => ({\n        url: requestUrl.href,\n        requestInterval: requestHostData.requestInterval,\n        currentDelay: currentRequestDelay,\n      }));\n      await new Promise(resolve => setTimeout(resolve, currentRequestDelay));\n    }\n\n    const registerCompletedRequest = (success: boolean): void => {\n      const requestDuration = (success ? 1 : this.failureMultiplier) *\n        (Date.now() - currentTimestamp - currentRequestDelay);\n      if (requestHostData.requestInterval < 0) {\n        requestHostData.requestInterval = Math.round(requestDuration * this.correctionMultiplier);\n      } else {\n        requestHostData.requestInterval += Math.round(this.correctionMultiplier * (\n          requestDuration - requestHostData.requestInterval\n        ));\n      }\n      if (!success && !requestHostData.rateLimited) {\n        this.logDebug(action.context, 'Marking host as rate-limited', () => ({\n          host: requestUrl.host,\n        }));\n        requestHostData.rateLimited = true;\n      }\n    };\n\n    try {\n      const response = await this.mediatorHttp.mediate({\n        ...action,\n        context: action.context.set(ActorHttpLimitRate.keyWrapped, true),\n      });\n      registerCompletedRequest(response.ok);\n      return response;\n    } catch (error: unknown) {\n      registerCompletedRequest(false);\n      throw error;\n    }\n  }\n\n  /**\n   * Handles HTTP cache invalidation events.\n   * @param {IActionHttpInvalidate} action The invalidation action\n   */\n  public handleHttpInvalidateEvent(action: IActionHttpInvalidate): void {\n    if (action.url) {\n      const invalidatedHost = new URL(action.url).host;\n      this.hostData.delete(invalidatedHost);\n    } else {\n      this.hostData.clear();\n    }\n  }\n}\n\ninterface IHostData {\n  /**\n   * The determined request interval for the host.\n   */\n  requestInterval: number;\n  /**\n   * The timestamp of the latest request to the host.\n   */\n  latestRequestTimestamp: number;\n  /**\n   * Whether the host is being rate limited.\n   */\n  rateLimited: boolean;\n}\n\nexport interface IActorHttpLimitRateArgs extends IActorHttpArgs {\n  /**\n   * The HTTP mediator.\n   */\n  mediatorHttp: MediatorHttp;\n  /* eslint-disable max-len */\n  /**\n   * An actor that listens to HTTP invalidation events\n   * @default {<default_invalidator> a <npmd:@comunica/bus-http-invalidate/^4.0.0/components/ActorHttpInvalidateListenable.jsonld#ActorHttpInvalidateListenable>}\n   */\n  httpInvalidator: ActorHttpInvalidateListenable;\n  /* eslint-enable max-len */\n  /**\n   * Multiplier for how aggressively the delay should follow the latest response time, ideally in range ]0.0, 1.0].\n   * @range {float}\n   * @default {0.1}\n   */\n  correctionMultiplier: number;\n  /**\n   * The response time of a failed request is taken into account with this multiplier applied.\n   * @range {float}\n   * @default {10.0}\n   */\n  failureMultiplier: number;\n  /**\n   * Whether rate limiting should be applied from the first request onwards, instead of waiting for a request to fail.\n   * Enabling this behaviour can help avoid spamming a server with large amounts of requests when execution begins.\n   * @range {boolean}\n   * @default {false}\n   */\n  limitByDefault: boolean;\n  /**\n   * Whether requests should be allowed to overlap, instead of being effectively queued one after another for a host.\n   * Enabling this behaviour may help with overall performance, but will make the rate limiter less accurate,\n   * and make it impossible for the limiter to smooth out large bursts of requests to a given host.\n   * @range {boolean}\n   * @default {false}\n   */\n  allowOverlap: boolean;\n}\n"]}
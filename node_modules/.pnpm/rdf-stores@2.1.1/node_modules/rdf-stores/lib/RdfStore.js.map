{"version":3,"file":"RdfStore.js","sourceRoot":"","sources":["RdfStore.ts"],"names":[],"mappings":"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","sourcesContent":["import type { EventEmitter } from 'events';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { wrap } from 'asynciterator';\nimport { DataFactory } from 'rdf-data-factory';\nimport type { QuadTermName } from 'rdf-terms';\nimport {\n  matchPattern,\n  matchPatternMappings,\n  QUAD_TERM_NAMES,\n} from 'rdf-terms';\nimport { DatasetCoreWrapper } from './dataset/DatasetCoreWrapper';\nimport type { ITermDictionary } from './dictionary/ITermDictionary';\nimport { TermDictionaryNumberRecordFullTerms } from './dictionary/TermDictionaryNumberRecordFullTerms';\nimport { TermDictionaryQuotedIndexed } from './dictionary/TermDictionaryQuotedIndexed';\nimport type { IRdfStoreIndex } from './index/IRdfStoreIndex';\nimport { RdfStoreIndexNestedMapQuoted } from './index/RdfStoreIndexNestedMapQuoted';\nimport type { IRdfStoreOptions } from './IRdfStoreOptions';\nimport { encodeOptionalTerms, getBestIndex, orderQuadComponents, quadToPattern } from './OrderUtils';\nimport type { EncodedQuadTerms, QuadPatternTerms } from './PatternTerm';\n\n/**\n * An RDF store allows quads to be stored and fetched, based on one or more customizable indexes.\n */\nexport class RdfStore<E = any, Q extends RDF.BaseQuad = RDF.Quad> implements RDF.Store<Q> {\n  public static readonly DEFAULT_INDEX_COMBINATIONS: QuadTermName[][] = [\n    [ 'graph', 'subject', 'predicate', 'object' ],\n    [ 'graph', 'predicate', 'object', 'subject' ],\n    [ 'graph', 'object', 'subject', 'predicate' ],\n  ];\n\n  public readonly options: IRdfStoreOptions<E, Q>;\n  public readonly dataFactory: RDF.DataFactory<Q>;\n  public readonly dictionary: ITermDictionary<E>;\n  public readonly indexesWrapped: IRdfStoreIndexWrapped<E>[];\n  private readonly indexesWrappedComponentOrders: QuadTermName[][];\n  public readonly features = { quotedTripleFiltering: true };\n\n  private _size = 0;\n\n  public constructor(options: IRdfStoreOptions<E, Q>) {\n    this.options = options;\n    this.dataFactory = options.dataFactory;\n    this.dictionary = options.dictionary;\n    this.indexesWrapped = RdfStore.constructIndexesWrapped(options);\n    this.indexesWrappedComponentOrders = this.indexesWrapped.map(indexThis => indexThis.componentOrder);\n  }\n\n  /**\n   * Create an RDF store with default settings.\n   * Concretely, this store stores triples in GSPO, GPOS, and GOSP order,\n   * and makes use of in-memory number dictionary encoding.\n   */\n  public static createDefault(): RdfStore<number> {\n    return new RdfStore<number>({\n      indexCombinations: RdfStore.DEFAULT_INDEX_COMBINATIONS,\n      indexConstructor: subOptions => new RdfStoreIndexNestedMapQuoted(subOptions),\n      dictionary: new TermDictionaryQuotedIndexed(new TermDictionaryNumberRecordFullTerms()),\n      dataFactory: new DataFactory(),\n    });\n  }\n\n  /**\n   * Internal helper to create index objects.\n   * @param options The RDF store options object.\n   */\n  public static constructIndexesWrapped<E, Q extends RDF.BaseQuad = RDF.Quad>(\n    options: IRdfStoreOptions<E, Q>,\n  ): IRdfStoreIndexWrapped<E>[] {\n    const indexes: IRdfStoreIndexWrapped<E>[] = [];\n    if (options.indexCombinations.length === 0) {\n      throw new Error('At least one index combination is required');\n    }\n    for (const componentOrder of options.indexCombinations) {\n      if (!RdfStore.isCombinationValid(componentOrder)) {\n        throw new Error(`Invalid index combination: ${componentOrder}`);\n      }\n      indexes.push({\n        index: options.indexConstructor(options),\n        componentOrder,\n        componentOrderInverse: <any>Object.fromEntries(componentOrder.map((value, key) => [ value, key ])),\n      });\n    }\n    return indexes;\n  }\n\n  /**\n   * Check if a given quad term order is valid.\n   * @param combination A quad term order.\n   */\n  public static isCombinationValid(combination: QuadTermName[]): boolean {\n    for (const quadTermName of QUAD_TERM_NAMES) {\n      if (!combination.includes(quadTermName)) {\n        return false;\n      }\n    }\n    return combination.length === 4;\n  }\n\n  /**\n   * The number of quads in this store.\n   */\n  public get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Add a quad to the store.\n   * @param quad An RDF quad.\n   * @return boolean If the quad was not yet present in the index.\n   */\n  public addQuad(quad: Q): boolean {\n    const quadEncoded = [\n      this.dictionary.encode(quad.subject),\n      this.dictionary.encode(quad.predicate),\n      this.dictionary.encode(quad.object),\n      this.dictionary.encode(quad.graph),\n    ];\n    let newQuad = false;\n    for (const indexWrapped of this.indexesWrapped) {\n      // Before sending the quad to the index, make sure its components are ordered corresponding to the index's order.\n      newQuad = indexWrapped.index\n        .set(<EncodedQuadTerms<E>>orderQuadComponents(indexWrapped.componentOrder, quadEncoded), true);\n    }\n    if (newQuad) {\n      this._size++;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Remove a quad from the store.\n   * @param quad An RDF quad.\n   * @return boolean If the quad was present in the index.\n   */\n  public removeQuad(quad: Q): boolean {\n    const quadEncoded = [\n      this.dictionary.encodeOptional(quad.subject),\n      this.dictionary.encodeOptional(quad.predicate),\n      this.dictionary.encodeOptional(quad.object),\n      this.dictionary.encodeOptional(quad.graph),\n    ];\n\n    // We can quickly return false if the quad is not present in the dictionary\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    if (quadEncoded.includes(undefined)) {\n      return false;\n    }\n\n    let wasPresent = false;\n    for (const indexWrapped of this.indexesWrapped) {\n      // Before sending the quad to the index, make sure its components are ordered corresponding to the index's order.\n      wasPresent = indexWrapped.index\n        .remove(<EncodedQuadTerms<E>>orderQuadComponents(indexWrapped.componentOrder, quadEncoded));\n      if (!wasPresent) {\n        break;\n      }\n    }\n    if (wasPresent) {\n      this._size--;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes all streamed quads.\n   * @param stream A stream of quads\n   */\n  public remove(stream: RDF.Stream<Q>): EventEmitter {\n    stream.on('data', quad => this.removeQuad(quad));\n    return stream;\n  }\n\n  /**\n   * All quads matching the pattern will be removed.\n   * @param subject The optional subject.\n   * @param predicate The optional predicate.\n   * @param object The optional object.\n   * @param graph The optional graph.\n   */\n  public removeMatches(\n    subject?: RDF.Term | null | undefined,\n    predicate?: RDF.Term | null | undefined,\n    object?: RDF.Term | null | undefined,\n    graph?: RDF.Term | null | undefined,\n  ): EventEmitter {\n    return this.remove(this.match(subject, predicate, object, graph));\n  }\n\n  /**\n   * Deletes the given named graph.\n   * @param graph The graph term or string to match.\n   */\n  public deleteGraph(graph: string | Q['graph']): EventEmitter {\n    if (typeof graph === 'string') {\n      graph = this.dataFactory.namedNode(graph);\n    }\n    return this.removeMatches(undefined, undefined, undefined, graph);\n  }\n\n  /**\n   * Import the given stream of quads into the store.\n   * @param stream A stream of RDF quads.\n   */\n  public import(stream: RDF.Stream<Q>): EventEmitter {\n    stream.on('data', (quad: Q) => this.addQuad(quad));\n    return stream;\n  }\n\n  /**\n   * Returns a generator producing all quads matching the pattern.\n   * @param subject The optional subject.\n   * @param predicate The optional predicate.\n   * @param object The optional object.\n   * @param graph The optional graph.\n   */\n  public * readQuads(\n    subject?: RDF.Term | null,\n    predicate?: RDF.Term | null,\n    object?: RDF.Term | null,\n    graph?: RDF.Term | null,\n  ): IterableIterator<Q> {\n    // Check if our dictionary and our indexes have quoted pattern support\n    const indexesSupportQuotedPatterns = Boolean(this.dictionary.features.quotedTriples) &&\n      Object.values(this.indexesWrapped).every(wrapped => wrapped.index.features.quotedTripleFiltering);\n\n    // Construct a quad pattern array\n    const [ quadComponents, requireQuotedTripleFiltering ] =\n      quadToPattern(subject, predicate, object, graph, indexesSupportQuotedPatterns);\n\n    // Determine the best index for this pattern\n    const indexWrapped = this.indexesWrapped[getBestIndex(this.indexesWrappedComponentOrders, quadComponents)];\n\n    // Re-order the quad pattern based on this best index's component order\n    const quadComponentsOrdered = <QuadPatternTerms> orderQuadComponents(indexWrapped.componentOrder, quadComponents);\n\n    // Call the best index's find method.\n    // eslint-disable-next-line unicorn/no-array-callback-reference\n    for (const decomposedQuad of indexWrapped.index.find(quadComponentsOrdered)) {\n      // De-order the resulting quad components into the normal SPOG order for quad creation.\n      const quad = this.dataFactory.quad(\n        decomposedQuad[indexWrapped.componentOrderInverse.subject],\n        decomposedQuad[indexWrapped.componentOrderInverse.predicate],\n        decomposedQuad[indexWrapped.componentOrderInverse.object],\n        decomposedQuad[indexWrapped.componentOrderInverse.graph],\n      );\n      if (requireQuotedTripleFiltering) {\n        if (matchPattern(quad, subject!, predicate!, object!, graph!)) {\n          yield quad;\n        }\n      } else {\n        yield quad;\n      }\n    }\n  }\n\n  /**\n   * Returns an array containing all quads matching the pattern.\n   * @param subject The optional subject.\n   * @param predicate The optional predicate.\n   * @param object The optional object.\n   * @param graph The optional graph.\n   */\n  public getQuads(\n    subject?: RDF.Term | null,\n    predicate?: RDF.Term | null,\n    object?: RDF.Term | null,\n    graph?: RDF.Term | null,\n  ): Q[] {\n    return [ ...this.readQuads(subject, predicate, object, graph) ];\n  }\n\n  /**\n   * Returns a stream that produces all quads matching the pattern.\n   * @param subject The optional subject.\n   * @param predicate The optional predicate.\n   * @param object The optional object.\n   * @param graph The optional graph.\n   */\n  public match(\n    subject?: RDF.Term | null,\n    predicate?: RDF.Term | null,\n    object?: RDF.Term | null,\n    graph?: RDF.Term | null,\n  ): RDF.Stream<Q> & AsyncIterator<Q> {\n    return wrap(this.readQuads(subject, predicate, object, graph));\n  }\n\n  /**\n   * Returns a generator producing all quads matching the pattern.\n   * @param subject The subject, which can be a variable.\n   * @param predicate The predicate, which can be a variable.\n   * @param object The object, which can be a variable.\n   * @param graph The graph, which can be a variable.\n   */\n  public * readBindings(\n    bindingsFactory: RDF.BindingsFactory,\n    subject: RDF.Term,\n    predicate: RDF.Term,\n    object: RDF.Term,\n    graph: RDF.Term,\n  ): IterableIterator<RDF.Bindings> {\n    // Check if our dictionary and our indexes have quoted pattern support\n    const indexesSupportQuotedPatterns = Boolean(this.dictionary.features.quotedTriples) &&\n      Object.values(this.indexesWrapped).every(wrapped => wrapped.index.features.quotedTripleFiltering);\n\n    // Construct a quad pattern array\n    const [ quadComponents, requireQuotedTripleFiltering ] =\n      quadToPattern(subject, predicate, object, graph, indexesSupportQuotedPatterns);\n\n    // Determine the best index for this pattern\n    const indexWrapped = this.indexesWrapped[getBestIndex(this.indexesWrappedComponentOrders, quadComponents)];\n\n    // Re-order the quad pattern based on this best index's component order\n    const quadComponentsOrdered = <QuadPatternTerms> orderQuadComponents(indexWrapped.componentOrder, quadComponents);\n    const ids = encodeOptionalTerms(quadComponentsOrdered, this.dictionary);\n\n    // Abort if any of the terms does not exist in the dictionary\n    if (!ids) {\n      return;\n    }\n\n    // Collect variables to bind\n    const terms = orderQuadComponents(indexWrapped.componentOrder, [ subject, predicate, object, graph ]);\n    const variableIndexes: number[] = [];\n    for (let i = 0; i < terms.length; i++) {\n      if (terms[i].termType === 'Variable' || terms[i].termType === 'Quad') {\n        variableIndexes.push(i);\n      }\n    }\n\n    // Check if we need to do post-filtering for overlapping variables\n    let shouldFilterIndexes = false;\n    const filterIndexes = terms.map((variable, i) => {\n      const equalVariables = [];\n      for (let j = i + 1; j < terms.length; j++) {\n        if (variable.equals(terms[j])) {\n          equalVariables.push(j);\n          shouldFilterIndexes = true;\n        }\n      }\n      return equalVariables;\n    });\n\n    // Call the best index's find method.\n    for (const decomposedQuadEncoded of indexWrapped.index\n      .findEncoded(<EncodedQuadTerms<E | undefined>> ids, quadComponentsOrdered)) {\n      let skipBinding = false;\n      let checkForBindingConflicts = false;\n      const bindingsEntries: [RDF.Variable, RDF.Term][] = [];\n      for (const i of variableIndexes) {\n        // If we had overlapping variables, potentially exclude this binding if values for variable are unequal\n        if (shouldFilterIndexes) {\n          const filterI = filterIndexes[i];\n          if (filterI) {\n            for (const j of filterI) {\n              if (decomposedQuadEncoded[i] !== decomposedQuadEncoded[j]) {\n                skipBinding = true;\n                break;\n              }\n            }\n          }\n          if (skipBinding) {\n            break;\n          }\n        }\n\n        const decodedTerm = this.dictionary.decode(decomposedQuadEncoded[i]);\n\n        // Handle quoted triples\n        // TODO: it may be possible to implement a more efficient of findEncoded if requireQuotedTripleFiltering is\n        //  false that would return bindings instead of quads. The following could then be skipped.\n        //  variableIndexes would also need to be changed to check requireQuotedTripleFiltering (see readQuads).\n        if (terms[i].termType === 'Quad') {\n          if (decodedTerm.termType === 'Quad') {\n            // If the term is a quad, it may also contain nested variables,\n            // so we need to extract those additional bindings.\n            const additionalBindings = matchPatternMappings(decodedTerm, terms[i], { returnMappings: true });\n            if (additionalBindings) {\n              checkForBindingConflicts = true;\n              for (const [ key, value ] of Object.entries(additionalBindings)) {\n                const variable = this.dataFactory.variable!(key);\n                if (bindingsEntries.some(entry => entry[0].equals(variable) && !entry[1].equals(value))) {\n                  // Skip this binding if we find conflicting variable bindings\n                  skipBinding = true;\n                  break;\n                }\n                bindingsEntries.push([ variable, value ]);\n              }\n              continue;\n            }\n          }\n          skipBinding = true;\n          break;\n        }\n\n        // If for the current bindings object, we previously found a quoted quad term that bound variables within it,\n        // make sure that later bindings to this variable from other terms don't conflict.\n        if (checkForBindingConflicts && bindingsEntries\n          .some(entry => entry[0].equals(terms[i]) && !entry[1].equals(decodedTerm))) {\n          // Skip this binding if we find conflicting variable bindings\n          skipBinding = true;\n          break;\n        }\n\n        bindingsEntries.push([ <RDF.Variable> terms[i], decodedTerm ]);\n      }\n\n      if (!skipBinding) {\n        // Create and yield the bindings object\n        yield bindingsFactory.bindings(bindingsEntries);\n      }\n    }\n  }\n\n  /**\n   * Returns an array containing all bindings matching the pattern.\n   * @param bindingsFactory The factory that will be used to create bindings.\n   * @param subject The subject, which can be a variable.\n   * @param predicate The predicate, which can be a variable.\n   * @param object The object, which can be a variable.\n   * @param graph The graph, which can be a variable.\n   */\n  public getBindings(\n    bindingsFactory: RDF.BindingsFactory,\n    subject: RDF.Term,\n    predicate: RDF.Term,\n    object: RDF.Term,\n    graph: RDF.Term,\n  ): RDF.Bindings[] {\n    return [ ...this.readBindings(bindingsFactory, subject, predicate, object, graph) ];\n  }\n\n  /**\n   * Returns a stream that produces all quads matching the pattern.\n   * @param bindingsFactory The factory that will be used to create bindings.\n   * @param subject The subject, which can be a variable.\n   * @param predicate The predicate, which can be a variable.\n   * @param object The object, which can be a variable.\n   * @param graph The graph, which can be a variable.\n   */\n  public matchBindings(\n    bindingsFactory: RDF.BindingsFactory,\n    subject: RDF.Term,\n    predicate: RDF.Term,\n    object: RDF.Term,\n    graph: RDF.Term,\n  ): AsyncIterator<RDF.Bindings> {\n    return wrap(this.readBindings(bindingsFactory, subject, predicate, object, graph));\n  }\n\n  /**\n   * Returns the exact cardinality of the quads matching the pattern.\n   * @param subject The optional subject.\n   * @param predicate The optional predicate.\n   * @param object The optional object.\n   * @param graph The optional graph.\n   */\n  public countQuads(\n    subject?: RDF.Term | null,\n    predicate?: RDF.Term | null,\n    object?: RDF.Term | null,\n    graph?: RDF.Term | null,\n  ): number {\n    // Check if our dictionary and our indexes have quoted pattern support\n    const indexesSupportQuotedPatterns = Boolean(this.dictionary.features.quotedTriples) &&\n      Object.values(this.indexesWrapped).every(wrapped => wrapped.index.features.quotedTripleFiltering);\n\n    // Construct a quad pattern array\n    const [ quadComponents ] =\n      quadToPattern(subject, predicate, object, graph, indexesSupportQuotedPatterns);\n\n    // Optimize all-variables pattern\n    if (quadComponents.every(quadComponent => quadComponent === undefined)) {\n      return this.size;\n    }\n\n    // Determine the best index for this pattern\n    const indexWrapped = this.indexesWrapped[getBestIndex(this.indexesWrappedComponentOrders, quadComponents)];\n\n    // Re-order the quad pattern based on this best index's component order\n    const quadComponentsOrdered = <QuadPatternTerms> orderQuadComponents(indexWrapped.componentOrder, quadComponents);\n\n    // Call the best index's count method.\n    return indexWrapped.index.count(quadComponentsOrdered);\n  }\n\n  /**\n   * Wrap this store inside a DatasetCore interface.\n   * Any mutations in either this store or the wrapper will propagate to each other.\n   */\n  public asDataset(): DatasetCoreWrapper<E, Q> {\n    return new DatasetCoreWrapper(this);\n  }\n}\n\nexport interface IRdfStoreIndexWrapped<E> {\n  componentOrder: QuadTermName[];\n  componentOrderInverse: Record<QuadTermName, number>;\n  index: IRdfStoreIndex<E, boolean>;\n}\n"]}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BindingsRaw = void 0;
const core_1 = require("@comunica/core");
const bindingsToString_1 = require("./bindingsToString");
/**
 * An immutable.js-based BindingsRaw object.
 */
class BindingsRaw {
    constructor(dataFactory, entries, contextHolder) {
        this.type = 'bindings';
        this.dataFactory = dataFactory;
        this.entries = entries;
        this.contextHolder = contextHolder;
    }
    has(key) {
        return (typeof key === 'string' ? key : key.value) in this.entries;
    }
    get(key) {
        return this.entries[typeof key === 'string' ? key : key.value];
    }
    set(key, value) {
        return new BindingsRaw(this.dataFactory, { ...this.entries, [typeof key === 'string' ? key : key.value]: value }, this.contextHolder);
    }
    delete(key) {
        const entries = { ...this.entries };
        delete entries[typeof key === 'string' ? key : key.value];
        return new BindingsRaw(this.dataFactory, entries, this.contextHolder);
    }
    keys() {
        return Object.keys(this.entries).map(key => this.dataFactory.variable(key));
    }
    values() {
        return Object.values(this.entries);
    }
    forEach(fn) {
        for (const [key, value] of Object.entries(this.entries)) {
            fn(value, this.dataFactory.variable(key));
        }
    }
    get size() {
        return Object.keys(this.entries).length;
    }
    [Symbol.iterator]() {
        return Object.entries(this.entries)
            .map(([key, value]) => [this.dataFactory.variable(key), value])[Symbol.iterator]();
    }
    equals(other) {
        if (!other) {
            return false;
        }
        if (this === other) {
            return true;
        }
        // First check if size is equal
        if (this.size !== other.size) {
            return false;
        }
        // Then check if keys and values are equal
        for (const key of this.keys()) {
            if (!this.get(key)?.equals(other.get(key))) {
                return false;
            }
        }
        return true;
    }
    filter(fn) {
        return new BindingsRaw(this.dataFactory, Object.fromEntries(Object.entries(this.entries)
            .filter(([key, value]) => fn(value, this.dataFactory.variable(key)))), this.contextHolder);
    }
    map(fn) {
        return new BindingsRaw(this.dataFactory, Object.fromEntries(Object.entries(this.entries)
            .map(([key, value]) => [key, fn(value, this.dataFactory.variable(key))])), this.contextHolder);
    }
    merge(other) {
        if (this.size < other.size && other instanceof BindingsRaw) {
            return other.merge(this);
        }
        const entries = { ...this.entries };
        // Check if other is of type BindingsRaw, in that case we can access entries immediately.
        // This skips the unnecessary conversion from string to variable.
        if (other instanceof BindingsRaw) {
            for (const [variable, right] of Object.entries(other.entries)) {
                const left = this.entries[variable];
                if (left && !left.equals(right)) {
                    return;
                }
                entries[variable] = right;
            }
        }
        else {
            for (const [variable, right] of other) {
                const left = this.entries[variable.value];
                if (left && !left.equals(right)) {
                    return;
                }
                entries[variable.value] = right;
            }
        }
        return this.createBindingsWithContexts(entries, other);
    }
    mergeWith(merger, other) {
        if (this.size < other.size && other instanceof BindingsRaw) {
            return other.mergeWith(merger, this);
        }
        const entries = { ...this.entries };
        // For code comments see BindingsRaw.merge function
        if (other instanceof BindingsRaw) {
            for (const [variable, right] of Object.entries(other.entries)) {
                const left = this.entries[variable];
                let value;
                if (left && !left.equals(right)) {
                    value = merger(left, right, this.dataFactory.variable(variable));
                }
                else {
                    value = right;
                }
                entries[variable] = value;
            }
        }
        else {
            for (const [variable, right] of other) {
                const left = this.entries[variable.value];
                let value;
                if (left && !left.equals(right)) {
                    value = merger(left, right, variable);
                }
                else {
                    value = right;
                }
                entries[variable.value] = value;
            }
        }
        return this.createBindingsWithContexts(entries, other);
    }
    createBindingsWithContexts(entries, other) {
        // If any context is empty, we skip merging contexts
        if (this.contextHolder && this.contextHolder.context) {
            let mergedContext = this.contextHolder.context;
            // Only merge if the other has a context
            if ('contextHolder' in other && other.contextHolder && other.contextHolder.context) {
                mergedContext = BindingsRaw
                    .mergeContext(this.contextHolder.contextMergeHandlers, mergedContext, other.contextHolder.context);
            }
            return new BindingsRaw(this.dataFactory, entries, { contextMergeHandlers: this.contextHolder.contextMergeHandlers, context: mergedContext });
        }
        // Otherwise, use optional context from other
        return new BindingsRaw(this.dataFactory, entries, other.contextHolder);
    }
    static mergeContext(contextMergeHandlers, context, otherContext) {
        // All keys can contain duplicates, we prevent this by checking our built datamap for duplicates
        const allKeys = [...context.keys(), ...otherContext.keys()];
        // Map we build up with merged context values
        const newContextData = {};
        const handledKeys = {};
        // Set of names of keys in other context to allow for constant time lookup
        const keysSetOtherContext = new Set(otherContext.keys().map(key => key.name));
        const keysBothContext = context.keys().filter(key => keysSetOtherContext.has(key.name));
        for (const key of allKeys) {
            // If duplicate key, we continue iterating
            if (handledKeys[key.name] === 1) {
                continue;
            }
            // We've processed this key and shouldn't repeat it
            handledKeys[key.name] = 1;
            // Determine whether this key occurs in both contexts
            const occursInBoth = keysBothContext.some(x => x.name === key.name);
            // If we execute this function, we already check for existence of context merge handlers
            // This if statement is first as the most likely case for non-empty contexts is that we have mergehandlers
            // and both contexts have an entry
            if (contextMergeHandlers[key.name] && occursInBoth) {
                newContextData[key.name] = contextMergeHandlers[key.name]
                    .run(context.get(key), otherContext.get(key));
                continue;
            }
            // If we have no merge handler, but both contexts have entries for key, we don't add it to new context
            if (!contextMergeHandlers[key.name] && occursInBoth) {
                continue;
            }
            // If key doesn't occur in own context, it must be in other context
            // (if we get to this point, the key doesn't occur in both)
            if (!context.get(key)) {
                newContextData[key.name] = otherContext.get(key);
                continue;
            }
            // This could likely be else statement, but don't want to risk it
            if (!otherContext.get(key)) {
                newContextData[key.name] = context.get(key);
            }
        }
        return new core_1.ActionContext(newContextData);
    }
    setContextEntry(key, value) {
        return this.setContextEntryRaw(key, value);
    }
    setContextEntryRaw(key, value) {
        if (this.contextHolder && this.contextHolder.context) {
            return new BindingsRaw(this.dataFactory, this.entries, {
                contextMergeHandlers: this.contextHolder.contextMergeHandlers,
                context: this.contextHolder.context.set(key, value),
            });
        }
        return new BindingsRaw(this.dataFactory, this.entries, {
            contextMergeHandlers: this.contextHolder?.contextMergeHandlers ?? {},
            context: new core_1.ActionContext().set(key, value),
        });
    }
    deleteContextEntry(key) {
        return this.deleteContextEntryRaw(key);
    }
    deleteContextEntryRaw(key) {
        if (this.contextHolder) {
            return new BindingsRaw(this.dataFactory, this.entries, {
                contextMergeHandlers: this.contextHolder.contextMergeHandlers,
                context: this.contextHolder.context?.delete(key),
            });
        }
        return new BindingsRaw(this.dataFactory, this.entries);
    }
    getContext() {
        return this.contextHolder?.context;
    }
    getContextEntry(key) {
        return this.getContext()?.get(key);
    }
    toString() {
        return (0, bindingsToString_1.bindingsToString)(this);
    }
    *mapIterable(iterable, callback) {
        for (const x of iterable) {
            yield callback(x);
        }
    }
    iteratorToIterable(iterator) {
        return {
            [Symbol.iterator]: () => iterator,
        };
    }
}
exports.BindingsRaw = BindingsRaw;
//# sourceMappingURL=BindingsRaw.js.map
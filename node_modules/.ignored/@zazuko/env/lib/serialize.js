import { Transform } from 'stream';
import getStream from 'get-stream';
import knownPrefixes from '@zazuko/prefixes';
import toCanonical from 'rdf-dataset-ext/toCanonical.js';
import toStream from 'rdf-dataset-ext/toStream.js';
export async function serialize(env, dataset, { renameBlankNodes, format, prefixes = [] }) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const serializer = env.formats.serializers.get(format);
    if (!serializer) {
        return toCanonical(dataset);
    }
    let stream = toStream(dataset);
    if (renameBlankNodes) {
        stream = stream.pipe(new RenameBlankNodes(env));
    }
    return getStream(serializer.import(stream, {
        prefixes: prefixes.reduce((map, prefix) => {
            if (Array.isArray(prefix)) {
                return { ...map, [prefix[0]]: prefix[1] };
            }
            if (prefix in knownPrefixes) {
                return { ...map, [prefix]: knownPrefixes[prefix] };
            }
            return map;
        }, {}),
    }));
}
class RenameBlankNodes extends Transform {
    env;
    blankNodes;
    constructor(env) {
        super({ objectMode: true });
        this.env = env;
        this.blankNodes = env.termMap();
    }
    _transform(chunk, encoding, callback) {
        let replaced = false;
        let { subject, predicate, object } = chunk;
        if (subject && subject.termType === 'BlankNode') {
            subject = this.replaceBlankNode(subject);
            replaced = true;
        }
        if (object && object.termType === 'BlankNode') {
            object = this.replaceBlankNode(object);
            replaced = true;
        }
        if (!replaced) {
            callback(null, chunk);
        }
        else {
            callback(null, this.env.quad(subject, predicate, object));
        }
    }
    replaceBlankNode(original) {
        if (!this.blankNodes.has(original)) {
            const replacement = this.env.blankNode(`t${this.blankNodes.size}`);
            this.blankNodes.set(original, replacement);
        }
        return this.blankNodes.get(original);
    }
}
